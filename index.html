<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>T-CHAT_LINK_V2.0</title>
    <link rel="icon" type="image/png" href="tchat.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Default Theme: Green Phosphor */
            --terminal-main: #33ff00;
            --terminal-glow: #33ff00;
            --terminal-bg: #0a0a0a;
            --bezel-color: #222;
            
            /* Secondary colors */
            --system-color: #ffaa00; 
            --chat-color: #00ccff;
            --error-color: #ff3333;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--terminal-bg);
            height: 100dvh; 
            width: 100vw;
            font-family: 'VT323', monospace;
            overflow: hidden;
        }

        .crt-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .bezel-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 25px solid var(--bezel-color);
            border-radius: 20px;
            box-shadow: inset 0 0 20px #000;
            pointer-events: none;
            z-index: 20;
        }

        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
            z-index: 10;
            animation: flicker 0.15s infinite;
        }

        .crt-overlay::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.4) 100%);
            z-index: 10;
        }

        /* Flash Animation for Notifications */
        @keyframes screen-flash {
            0% { background-color: transparent; }
            50% { background-color: rgba(255, 51, 51, 0.3); }
            100% { background-color: transparent; }
        }

        .notification-flash {
            animation: screen-flash 0.5s ease-in-out;
        }

        .terminal-content {
            height: 100%;
            width: 100%;
            padding: 40px;
            box-sizing: border-box;
            color: var(--terminal-main);
            text-shadow: 0 0 4px var(--terminal-glow);
            font-size: 1.5rem;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            overflow: hidden; 
        }

        /* Scrollbar styles */
        #chat-history::-webkit-scrollbar { width: 10px; }
        #chat-history::-webkit-scrollbar-track { background: #000; }
        #chat-history::-webkit-scrollbar-thumb { background-color: var(--terminal-main); border: 2px solid #000; }

        #chat-history {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding-bottom: 20px;
            overflow-y: auto; 
            min-height: 0; 
            padding-right: 10px; 
        }

        /* Flexible bottom alignment */
        #chat-history > :first-child {
            margin-top: auto;
        }

        .message-line {
            margin-bottom: 0.5rem;
            word-wrap: break-word;
            line-height: 1.4;
            opacity: 0;
            animation: fadeIn 0.1s forwards;
            max-width: 90%;
            white-space: pre-wrap; 
            transition: opacity 0.5s ease-out;
            flex-shrink: 0; 
        }

        .highlight-mention {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
            padding: 0 4px;
            font-weight: bold;
        }

        .ascii-art {
            white-space: pre;
            font-size: 0.6rem; /* Small font for high density */
            line-height: 0.6rem;
            overflow-x: auto; /* Allow scrolling if needed */
            color: var(--terminal-main);
            margin: 10px 0;
            display: block;
            font-family: monospace;
            
            /* Hide scrollbar visuals */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE 10+ */
        }
        
        /* Hide scrollbar for Chrome/Safari/Opera */
        .ascii-art::-webkit-scrollbar { 
            display: none;
        }

        .system-msg { color: var(--system-color); text-shadow: 0 0 4px var(--system-color); }
        .chat-msg { color: var(--chat-color); text-shadow: 0 0 4px var(--chat-color); }
        .error-msg { color: var(--error-color); text-shadow: 0 0 4px var(--error-color); }
        .user-prefix { font-weight: bold; margin-right: 0.5rem; }

        .status-dot { display: inline-block; margin-right: 8px; font-size: 1.2rem; }
        .status-online { color: var(--terminal-main); text-shadow: 0 0 5px var(--terminal-main); }
        .status-away { color: var(--system-color); text-shadow: 0 0 5px var(--system-color); }
        .status-busy { color: var(--error-color); text-shadow: 0 0 5px var(--error-color); }

        .burn-timer { color: var(--error-color); margin-left: 10px; font-size: 0.8em; font-weight: bold; }

        .input-line {
            display: flex;
            align-items: baseline; 
            border-top: 1px dashed rgba(51, 255, 0, 0.3);
            padding-top: 15px;
            padding-bottom: 5px;
            background-color: var(--terminal-bg); 
            position: relative;
            opacity: 0; 
            transition: opacity 0.5s;
            flex-shrink: 0; 
            z-index: 5;
        }

        .prompt { 
            margin-right: 15px; 
            font-weight: bold; 
            margin-top: 0; 
            white-space: nowrap;
        }

        .cmd-wrapper {
            position: relative;
            flex-grow: 1;
            display: flex;
            align-items: flex-start;
            min-height: 1.5rem; 
            height: auto;
        }

        #command-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            z-index: 10;
            cursor: text;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            line-height: 1.5rem;
            border: none;
            outline: none;
            background: transparent;
            color: transparent;
            resize: none;
            overflow: hidden;
            white-space: pre-wrap; 
            word-break: break-all;
            padding: 0;
            margin: 0;
        }

        #cmd-display {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            line-height: 1.5rem;
            color: var(--terminal-main);
            text-shadow: 0 0 4px var(--terminal-glow);
            white-space: pre-wrap; 
            word-break: break-all;
            pointer-events: none;
            display: block; 
            width: 100%;
            overflow: visible;
            min-height: 1.5rem;
        }

        #cmd-cursor {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
            animation: blink 1s step-end infinite;
            min-width: 1ch;
            display: inline-block;
            text-align: center;
            vertical-align: baseline; 
            line-height: 1;
        }

        .input-line:not(:focus-within) #cmd-cursor {
            background-color: transparent;
            color: var(--terminal-main);
            border: 1px solid var(--terminal-main);
            animation: none;
        }

        #autocomplete-menu {
            position: absolute;
            bottom: 100%; 
            left: 0;
            min-width: 200px;
            max-height: 250px;
            background-color: var(--terminal-bg);
            border: 1px solid var(--terminal-main);
            box-shadow: 0 0 10px rgba(0,0,0,0.8);
            display: none; 
            flex-direction: column;
            overflow-y: auto;
            z-index: 100;
        }
        
        #autocomplete-menu::-webkit-scrollbar { width: 5px; }
        #autocomplete-menu::-webkit-scrollbar-track { background: #000; }
        #autocomplete-menu::-webkit-scrollbar-thumb { background-color: var(--terminal-main); }

        .suggestion-item {
            padding: 5px 10px;
            color: var(--terminal-main);
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.3rem;
            border-bottom: 1px dotted rgba(51, 255, 0, 0.2);
        }

        .suggestion-item.selected, .suggestion-item:hover {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
        }

        /* --- TAB Button Styling --- */
        #tab-btn {
            background: transparent;
            border: 1px solid var(--terminal-main);
            color: var(--terminal-main);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            padding: 0 10px;
            height: 1.5rem;
            margin-left: 10px;
            cursor: pointer;
            text-shadow: 0 0 4px var(--terminal-glow);
            box-shadow: 0 0 4px var(--terminal-glow);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            margin-top: 0;
            align-self: flex-end; /* Stick to bottom of input line */
        }

        #tab-btn:active {
            background: var(--terminal-main);
            color: var(--terminal-bg);
        }

        /* --- Generic Overlay Styling --- */
        .utility-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            background-color: var(--terminal-bg);
            border: 2px solid var(--terminal-main);
            z-index: 50;
            display: none;
            flex-direction: column;
            padding: 2px;
            box-shadow: 0 0 20px rgba(0,0,0,0.9);
            overflow-y: auto;
        }
        
        .utility-overlay::-webkit-scrollbar { width: 8px; }
        .utility-overlay::-webkit-scrollbar-track { background: #000; }
        .utility-overlay::-webkit-scrollbar-thumb { background-color: var(--terminal-main); }

        .editor-header {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
            text-align: center;
            padding: 5px;
            font-weight: bold;
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        /* --- Profile Editor & Post Editor Styles --- */
        .editor-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Changed to start for multiline fields */
            padding: 8px 10px;
            border-bottom: 1px dotted rgba(51, 255, 0, 0.2);
            font-size: 1.2rem;
            cursor: pointer;
            user-select: none; 
        }

        .editor-row.active { background-color: rgba(51, 255, 0, 0.2); }
        .field-label { width: 30%; font-weight: bold; padding-top: 2px;}
        .field-value { 
            width: 65%; 
            white-space: pre-wrap; 
            word-break: break-all; 
            min-height: 1.5em; 
            border-bottom: 1px dashed var(--terminal-main); 
            display: block;
        }
        
        .terminal-inline-input {
            background: transparent;
            border: none;
            color: var(--terminal-main);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            width: 100%;
            outline: none;
            padding: 0;
            margin: 0;
            text-shadow: 0 0 4px var(--terminal-glow);
        }
        
        /* Post Editor Specifics */
        .post-textarea {
            width: 100%;
            height: 200px;
            background: transparent;
            border: none;
            color: var(--terminal-main);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            resize: none;
            outline: none;
        }

        .editor-actions {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 10px;
            flex-shrink: 0;
        }

        .action-btn {
            border: 1px solid var(--terminal-main);
            padding: 5px 15px;
            cursor: pointer;
            user-select: none;
        }
        .action-btn.active, .action-btn:hover {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
        }

        /* --- Profile Viewer Styles --- */
        .profile-bio-section {
            padding: 10px;
            border-bottom: 2px double var(--terminal-main);
            margin-bottom: 10px;
        }
        .post-list-section {
            padding: 10px;
        }
        .post-list-item {
            padding: 5px;
            cursor: pointer;
            border-bottom: 1px dotted rgba(51,255,0,0.3);
        }
        .post-list-item.selected {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
        }
        .post-date { font-size: 0.8em; float: right; }

        /* --- Post Reader Styles --- */
        .post-reader-content {
            padding: 20px;
            white-space: pre-wrap;
        }
        .reader-title { font-size: 1.8rem; font-weight: bold; border-bottom: 1px solid var(--terminal-main); margin-bottom: 10px; }
        .reader-meta { font-size: 0.9rem; color: var(--system-color); margin-bottom: 20px; }

        @keyframes flicker {
            0% { opacity: 0.97; } 50% { opacity: 0.99; } 100% { opacity: 0.94; }
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        @keyframes fadeIn { to { opacity: 1; } }

        .power-led {
            width: 10px; height: 10px; background-color: #ff0000; border-radius: 50%;
            position: absolute; bottom: 30px; right: 30px; box-shadow: 0 0 8px #ff0000;
            z-index: 25; pointer-events: none;
        }

        .brand-logo {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            color: #333; font-size: 1rem; font-family: sans-serif; letter-spacing: 4px;
            font-weight: bold; z-index: 25; pointer-events: none;
            text-shadow: 0 1px 1px rgba(255,255,255,0.1);
        }

        @media (max-width: 768px) {
            .bezel-overlay { border-width: 10px; border-radius: 12px; }
            .terminal-content { padding: 15px; padding-bottom: 20px; font-size: 1.2rem; }
            .input-line { padding-top: 10px; }
            .prompt { margin-right: 5px; }
            #command-input, #cmd-display { font-size: 1.2rem; }
            .brand-logo { font-size: 0.7rem; bottom: 2px; letter-spacing: 1px; opacity: 0.5; }
            .power-led { width: 6px; height: 6px; bottom: 10px; right: 10px; }
            #autocomplete-menu { max-height: 180px; min-width: 150px; bottom: 100%; left: 0; }
            .suggestion-item { font-size: 1.2rem; padding: 8px; }
            
            /* Tab button adjustment for mobile */
            #tab-btn {
                font-size: 1rem;
                padding: 0 6px;
                margin-left: 6px;
                height: 1.4rem;
            }
        }
    </style>
</head>
<body>
    <div class="crt-container">
        <div class="crt-overlay" id="crt-overlay"></div>
        <div class="bezel-overlay"></div>
        <div class="power-led"></div>
        <div class="brand-logo"></div>

        <div class="terminal-content" id="terminal-container">
            <div id="chat-history"></div>

            <div class="input-line" id="input-line-container">
                <span class="prompt" id="prompt-span">...</span>
                <div class="cmd-wrapper">
                    <div id="autocomplete-menu"></div>
                    <!-- Switched to Textarea for multiline -->
                    <textarea id="command-input" rows="1" spellcheck="false" autocomplete="off"></textarea>
                    <input type="file" id="file-upload" accept="image/*" style="display:none">
                    <!-- FIX: Removed all whitespace between spans -->
                    <div id="cmd-display"><span id="cmd-before"></span><span id="cmd-cursor">&nbsp;</span><span id="cmd-after"></span></div>
                </div>
                <!-- Tab Button for Android/Touch Devices -->
                <button id="tab-btn">TAB</button>
            </div>
        </div>
        
        <!-- Profile Editor Overlay (Existing) -->
        <div id="profile-editor-overlay" class="utility-overlay">
            <div class="editor-header">:: PROFILE EDITOR ::</div>
            
            <div class="editor-row" id="row-nick">
                <span class="field-label">NICKNAME:</span>
                <span class="field-value" id="edit-nick"></span>
            </div>
            
            <div class="editor-row" id="row-bio">
                <span class="field-label">BIO:</span>
                <span class="field-value" id="edit-bio"></span>
            </div>
            
            <div class="editor-row" id="row-avatar">
                <span class="field-label">AVATAR:</span>
                <span class="field-value" id="edit-avatar">[ TAP/SPACE TO UPLOAD ]</span>
            </div>
            
            <div class="editor-actions">
                <div class="action-btn" id="btn-save">[ SAVE ]</div>
                <div class="action-btn" id="btn-cancel">[ CANCEL ]</div>
            </div>
            <div style="text-align: center; font-size: 0.8rem; margin-top: 5px; color: var(--system-color);">[TAB] Nav | [SPACE] Edit</div>
        </div>

        <!-- NEW: Post Editor Overlay -->
        <div id="post-editor-overlay" class="utility-overlay">
            <div class="editor-header">:: CREATE NEW POST ::</div>
            
            <div class="editor-row" id="p-row-title">
                <span class="field-label">TITLE:</span>
                <span class="field-value" id="post-edit-title">[ ENTER TITLE ]</span>
            </div>

            <div class="editor-row" id="p-row-img">
                <span class="field-label">IMAGE:</span>
                <span class="field-value" id="post-edit-img">[ UPLOAD IMAGE (OPTIONAL) ]</span>
            </div>
            
            <div class="editor-row" id="p-row-body" style="flex-direction:column; align-items: stretch;">
                <span class="field-label" style="width:100%; margin-bottom:5px;">CONTENT:</span>
                <textarea id="post-edit-body" class="post-textarea" placeholder="Write your log here..."></textarea>
            </div>

            <div class="editor-actions">
                <div class="action-btn" id="btn-post-submit">[ PUBLISH ]</div>
                <div class="action-btn" id="btn-post-cancel">[ CANCEL ]</div>
            </div>
        </div>

        <!-- NEW: Profile Viewer (Data Bank) -->
        <div id="profile-viewer-overlay" class="utility-overlay">
            <div class="editor-header">:: USER DATA BANK ::</div>
            <div class="profile-bio-section" id="pv-bio-section">
                <!-- Populated by JS -->
            </div>
            <div class="editor-header" style="font-size: 1rem; border-top: 1px solid var(--terminal-main);">:: TRANSMISSION LOGS ::</div>
            <div class="post-list-section" id="pv-post-list">
                <!-- Populated by JS -->
            </div>
            <div class="editor-actions">
                <div class="action-btn" id="btn-pv-close">[ CLOSE ]</div>
            </div>
        </div>

        <!-- NEW: Post Reader -->
        <div id="post-reader-overlay" class="utility-overlay">
            <div class="editor-header">:: READER TERMINAL ::</div>
            <div class="post-reader-content" id="reader-content">
                <!-- Populated by JS -->
            </div>
            <div class="editor-actions">
                <div class="action-btn" id="btn-reader-close">[ CLOSE ]</div>
            </div>
        </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signInAnonymously, setPersistence, browserLocalPersistence, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, where, onSnapshot, orderBy, serverTimestamp, setDoc, doc, getDocs, getDoc, deleteDoc, limit, updateDoc, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuration ---
        // CRITICAL FIX: Use the system provided ID to avoid permission errors
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'tchat-terminal';
        
        const firebaseConfig = {
            apiKey: "AIzaSyCc4hgOZCeHnBgcwHk7mWMaQEbjodVLuc4",
            authDomain: "tchat-b75ee.firebaseapp.com",
            projectId: "tchat-b75ee",
            storageBucket: "tchat-b75ee.firebasestorage.app",
            messagingSenderId: "602448689642",
            appId: "1:602448689642:web:435a9f48ea2e80debeda93",
            measurementId: "G-T7P87XTZ15"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        setPersistence(auth, browserLocalPersistence).catch(console.error);

        // --- State ---
        let currentUser = null;
        let currentChatPartner = null; 
        let messagesUnsubscribe = null;
        let notificationUnsubscribe = null;

        const state = {
            mode: 'COMMAND', // COMMAND, CHAT, PROFILE_EDIT, POST_EDIT, PROFILE_VIEW, READER
            muted: false,
            booting: true, 
            theme: 'green'
        };
        
        // --- Command History ---
        const cmdHistory = [];
        let historyIndex = -1;

        // --- Autocomplete Data ---
        const commandsList = [
            'help', 'login', 'logout', 'friend', 'friends', 'friends-email', 'chat', 'reqbox',
            'burn', 'theme', 'ascii', 'mute', 'unmute', 'post', 'profile',
            'clear', 'status', 'date', 'exit', 'emoji', 'ping', 'neofetch', 'set-bio', 'whois', 'mentions'
        ];

        const subCommands = {
            'theme': ['green', 'amber', 'blue', 'white', 'matrix'],
            'status': ['online', 'away', 'busy'],
            'friend': ['add', 'nick']
        };

        let autocompleteOptions = [];
        let autocompleteIndex = -1;

        // --- Emoji Map ---
        const EMOJI_MAP = {
            '(acid)': 'âŠ‚(â—‰â€¿â—‰)ã¤', '(afraid)': '(ã†† _ ã††)', '(alpha)': 'Î±', '(angel)': 'â˜œ(âŒ’â–½âŒ’)â˜', '(angry)': 'â€¢`_Â´â€¢',
            '(arrowhead)': 'â¤œ(â±º Ê–Ì¯â±º)â¤', '(apple)': 'ï£¿', '(ass)': '(â€¿|â€¿)', '(butt)': '(â€¿|â€¿)', '(awkward)': 'â€¢Í¡Ë˜ã‡â€¢Í¡Ë˜',
            '(bat)': '/|\\ ^._.^ /|\\', '(bear)': 'Ê•Â·Í¡á´¥Â·Ê”ï»¿', '(koala)': 'Ê•Â·Í¡á´¥Â·Ê”ï»¿', '(bearflip)': 'Ê•ãƒâ€¢á´¥â€¢Ê”ãƒ ï¸µ â”»â”â”»',
            '(bearhug)': 'Ê•ã£â€¢á´¥â€¢Ê”ã£', '(because)': 'âˆµ', '(since)': 'âˆµ', '(beta)': 'Î²', '(bigheart)': 'â¤',
            '(bitcoin)': 'â‚¿', '(blackeye)': '0__#', '(blubby)': '( 0 _ 0 )', '(blush)': '(Ëµ Í¡Â° ÍœÊ– Í¡Â°Ëµ)',
            '(bond)': 'â”Œ( ÍÂ° ÍœÊ–Í¡Â°)=Îµ/ÌµÍ‡Ì¿Ì¿/â€™Ì¿â€™Ì¿ Ì¿', '(007)': 'â”Œ( ÍÂ° ÍœÊ–Í¡Â°)=Îµ/ÌµÍ‡Ì¿Ì¿/â€™Ì¿â€™Ì¿ Ì¿', '(boobs)': '( . Y . )', '(bored)': '(-_-)',
            '(bribe)': '( â€¢Í¡Ë˜ _â€¢Í¡Ë˜)ãƒÃ°', '(bubbles)': '( Ë˜ Â³Ë˜)ãƒÂ°ï¾ŸÂºâï½¡', '(butterfly)': 'Æ¸ÓœÆ·', '(cat)': '(= Ğ¤ã‚§Ğ¤=)',
            '(catlenny)': '( Í¡Â° á´¥ Í¡Â°)ï»¿', '(check)': 'âœ”', '(cheer)': 'â€»\\(^o^)/â€»', '(chubby)': 'â•­(Ê˜Ì†~â—à±ªâ—Ÿ~Ê˜Ì†)â•®',
            '(claro)': '(Í¡ Â° ÍœÊ– Í¡ Â°)', '(clique)': 'ãƒ½à¼¼ àºˆÙ„Íœàºˆà¼¼ â–€Ì¿Ì¿Ä¹Ì¯Ì¿Ì¿â–€Ì¿ Ì¿à¼½ÆŸÍ†Ù„ÍœÆŸÍ† à¼½ï¾‰', '(gang)': 'ãƒ½à¼¼ àºˆÙ„Íœàºˆà¼¼ â–€Ì¿Ì¿Ä¹Ì¯Ì¿Ì¿â–€Ì¿ Ì¿à¼½ÆŸÍ†Ù„ÍœÆŸÍ† à¼½ï¾‰',
            '(squad)': 'ãƒ½à¼¼ àºˆÙ„Íœàºˆà¼¼ â–€Ì¿Ì¿Ä¹Ì¯Ì¿Ì¿â–€Ì¿ Ì¿à¼½ÆŸÍ†Ù„ÍœÆŸÍ† à¼½ï¾‰', '(cloud)': 'â˜', '(club)': 'â™£', '(coffee)': 'c[_]', '(cuppa)': 'c[_]',
            '(cmd)': 'âŒ˜', '(command)': 'âŒ˜', '(cool)': '(â€¢_â€¢) ( â€¢_â€¢)>âŒâ– -â–  (âŒâ– _â– )', '(csi)': '(â€¢_â€¢) ( â€¢_â€¢)>âŒâ– -â–  (âŒâ– _â– )',
            '(copy)': 'Â©', '(c)': 'Â©', '(creep)': 'Ô…(â‰–â€¿â‰–Ô…)', '(creepcute)': 'Æª(Ú“×²)â€Æªâ€‹â€‹', '(crim3s)': '( âœœï¸µâœœ )',
            '(cross)': 'â€ ', '(cry)': '(â•¥ï¹â•¥)', '(crywave)': '( â•¥ï¹â•¥) ãƒã‚·', '(cute)': '(ï½¡â—•â€¿â€¿â—•ï½¡)', '(d1)': 'âš€',
            '(d2)': 'âš', '(d3)': 'âš‚', '(d4)': 'âšƒ', '(d5)': 'âš„', '(d6)': 'âš…', '(dab)': 'ãƒ½( â€¢_)á•—',
            '(damnyou)': '(á•— Í Â° à¨Š Í Â° )á•—', '(dance)': 'á••(âŒâ– _â– )á•— â™ªâ™¬', '(dead)': 'xâ¸‘x', '(dealwithit)': '(âŒâ– _â– )',
            '(dwi)': '(âŒâ– _â– )', '(delta)': 'Î”', '(depressed)': '(ï¸¶ï¸¹ï¸¶)', '(derp)': 'â˜‰ â€¿ âš†', '(diamond)': 'â™¦',
            '(dj)': 'd[-_-]b', '(dog)': '(â—•á´¥â—•Ê‹)', '(dollar)': '$', '(dollarbill)': '[Ì²Ì…$Ì²Ì…(Ì²Ì…Î¹Î¿Ì²Ì…Ì…)Ì²Ì…$Ì²Ì…]',
            '($)': '[Ì²Ì…$Ì²Ì…(Ì²Ì…Î¹Î¿Ì²Ì…Ì…)Ì²Ì…$Ì²Ì…]', '(dong)': '(Ì¿â–€Ì¿â€‰Ì¿Ä¹Ì¯Ì¿Ì¿â–€Ì¿ Ì¿)Ì„', '(donger)': 'ãƒ½à¼¼àºˆÙ„Íœàºˆà¼½ï¾‰', '(dontcare)': '(- Ê–Ì¯-)',
            '(idc)': '(- Ê–Ì¯-)', '(dontwant)': 'ãƒ½(ï½€Ğ”Â´)ï¾‰', '(do not want)': 'ãƒ½(ï½€Ğ”Â´)ï¾‰', '(dope)': '<(^_^)>',
            '(<<)': 'Â«', '(>>))': 'Â»', '(doubleflat)': 'ğ„«', '(doublesharp)': 'ğ„ª', '(doubletableflip)': 'â”»â”â”» ï¸µãƒ½(`Ğ”Â´)ï¾‰ï¸µ â”»â”â”»',
            '(down)': 'â†“', '(duckface)': '(ãƒ»3ãƒ»)', '(duel)': 'á••(â•­à²°â•­ ÍŸÊ–â•®â€¢Ì)âŠƒÂ¤=(â€”â€”â€”â€”-', '(duh)': '(â‰§ï¸¿â‰¦)',
            '(dunno)': 'Â¯\\(Â°_o)/Â¯', '(ebola)': 'á´‡Ê™á´ÊŸá´€', '(eeriemob)': '(-(-_-(-_(-_(-_-)_-)-_-)_-)_-)-)',
            '(ellipsis)': 'â€¦', '(...)': 'â€¦', '(emdash)': 'â€“', '(--)': 'â€“', '(emptystar)': 'â˜†',
            '(emptytriangle)': 'â–³', '(t2)': 'â–³', '(endure)': '(Ò‚â—¡_â—¡) á•¤', '(envelope)': 'âœ‰ï¸', '(letter)': 'âœ‰ï¸',
            '(epsilon)': 'É›', '(euro)': 'â‚¬', '(evil)': 'Ïˆ(ï½€âˆ‡Â´)Ïˆ', '(evillenny)': '(Í â‰– ÍœÊ–Í â‰–)',
            '(excited)': '(ï¾‰â—•ãƒ®â—•)ï¾‰*:ãƒ»ï¾Ÿâœ§', '(execution)': '(âŒâ– _â– )ï¸»â•¦â•¤â”€ (â•¥ï¹â•¥)', '(facebook)': '(â•¯Â°â–¡Â°)â•¯ï¸µ ÊooqÇÉ”ÉÉŸ',
            '(facepalm)': '(ï¼â€¸áƒš)', '(fancytext)': 'Ğ²Ñ”Ï‰Î±ÑÑ”, Î¹ Î±Ğ¼ Æ’Î±Î·Â¢Ñƒ!', '(fart)': '(Ë†âº«Ë†à¹‘)<3', '(fight)': '(à¸‡ â€¢Ì€_â€¢Ì)à¸‡',
            '(finn)': '| (â€¢ â—¡â€¢)|', '(fish)': '<"(((<3', '(5)': 'åŒ', '(five)': 'åŒ', '(5/8)': 'â…', '(flat)': 'â™­',
            '(bemolle)': 'â™­', '(flexing)': 'á•™(`â–½Â´)á•—', '(fliptext)': 'Ç×ŸqÉÊ‡ É ÇÊÄ±×Ÿ ÇÉ¯ dÄ±×ŸÉŸ',
            '(fliptexttable)': '(ãƒ ã‚œĞ”ã‚œ)ãƒ ï¸µ Ç×ŸqÉÊ‡ É ÇÊÄ±×Ÿ Ê‡xÇÊ‡ dÄ±×ŸÉŸ', '(flipped)': 'â”¬â”€â”¬ï»¿ ï¸µ /(.â–¡. \\ï¼‰',
            '(heavytable)': 'â”¬â”€â”¬ï»¿ ï¸µ /(.â–¡. \\ï¼‰', '(flower)': '(âœ¿â— â€¿â— )', '(flor)': '(âœ¿â— â€¿â— )', '(f)': 'âœ¿',
            '(fly)': 'â”€=â‰¡Î£((( ã¤â—•Ù„Íœâ—•)ã¤', '(friendflip)': '(â•¯Â°â–¡Â°)â•¯ï¸µ â”»â”â”» ï¸µ â•¯(Â°â–¡Â° â•¯)', '(frown)': '(áƒ¦Ë˜âŒ£Ë˜áƒ¦)',
            '(fuckoff)': 'à­§à¼¼à² ç›Šà² â•­âˆ©â•®à¼½', '(gtfo)': 'à­§à¼¼à² ç›Šà² â•­âˆ©â•®à¼½', '(fuckyou)': 'â”ŒĞŸâ”(à² _à² )', '(fu)': 'â”ŒĞŸâ”(à² _à² )',
            '(gentleman)': 'à² _à²°à³ƒ', '(sir)': 'à² _à²°à³ƒ', '(monocle)': 'à² _à²°à³ƒ', '(ghast)': '= _ =', '(ghost)': 'à¼¼ ã¤ â•¹ â•¹ à¼½ã¤',
            '(gift)': '(Â´ãƒ»Ï‰ãƒ»)ã£ç”±', '(present)': '(Â´ãƒ»Ï‰ãƒ»)ã£ç”±', '(gimme)': 'à¼¼ ã¤ â—•_â—• à¼½ã¤',
            '(givemeyourmoney)': '(â€¢-â€¢)âŒ', '(glitter)': '(*ãƒ»â€¿ãƒ»)ãƒâŒ’*:ï½¥ï¾Ÿâœ§', '(glasses)': '(âŒ Í¡â–  ÍœÊ– Í¡â– )',
            '(glassesoff)': '( Í¡Â° ÍœÊ– Í¡Â°)ï¾‰âŒâ– -â– ', '(glitterderp)': '(ï¾‰â˜‰ãƒ®âš†)ï¾‰ âŒ’*:ï½¥ï¾Ÿâœ§', '(gloomy)': '(_ã‚œ_ã‚œ_)',
            '(goatse)': '(Ğ·à¹Îµ)', '(gotit)': '(â˜ï¾Ÿâˆ€ï¾Ÿ)â˜', '(greet)': '( Â´â—” Ï‰â—”`) ãƒã‚·', '(greetings)': '( Â´â—” Ï‰â—”`) ãƒã‚·',
            '(gun)': 'ï¸»â•¦â•¤â”€', '(mg)': 'ï¸»â•¦â•¤â”€', '(hadouken)': 'à¼¼ã¤à² ç›Šà² à¼½ã¤ â”€=â‰¡Î£O))', '(hammerandsickle)': 'â˜­',
            '(hs)': 'â˜­', '(handleft)': 'â˜œ', '(hl)': 'â˜œ', '(handright)': 'â˜', '(hr)': 'â˜', '(haha)': 'Ù©(^â€¿^)Û¶',
            '(happy)': 'Ù©( à¹‘â•¹ ê‡´â•¹)Û¶', '(happygarry)': 'á••( á› )á•—', '(h)': 'â™¥', '(heart)': 'â™¥', '(hello)': '(Ê˜â€¿Ê˜)â•¯',
            '(ohai)': '(Ê˜â€¿Ê˜)â•¯', '(bye)': '(Ê˜â€¿Ê˜)â•¯', '(help)': '\\(Â°Î©Â°)/', '(highfive)': '._.)/\\(._.',
            '(hitting)': '( ï½€çš¿Â´)ï½¡ï¾/', '(hug)': '(ã¥ï½¡â—•â€¿â€¿â—•ï½¡)ã¥', '(hugs)': '(ã¥ï½¡â—•â€¿â€¿â—•ï½¡)ã¥',
            '(iknowright)': 'â”ï½œï½¥à¸´Ï‰ï½¥à¸´#ï½œâ”Œ', '(ikr)': 'â”ï½œï½¥à¸´Ï‰ï½¥à¸´#ï½œâ”Œ', '(illuminati)': 'à­§(â–²á´—â–²)ãƒ', '(infinity)': 'âˆ',
            '(inf)': 'âˆ', '(inlove)': '(ã£Â´Ï‰`c)â™¡', '(int)': 'âˆ«', '(internet)': 'à¬˜(à©­*ËŠáµ•Ë‹)à©­*â€ŠÌ€Ë‹ ÉªÉ´á´›á´‡Ê€É´á´‡á´›',
            '(interrobang)': 'â€½', '(jake)': '(âá´¥âÊ‹)', '(kappa)': '(Â¬,â€¿,Â¬)', '(kawaii)': 'â‰§â—¡â‰¦',
            '(keen)': 'â”¬â”´â”¬â”´â”¤ÆŸÍ†Ù„ÍœÆŸÍ† à¼½ï¾‰', '(kiahh)': '~\\(â‰§â–½â‰¦)/~', '(kiss)': '(ã¥ ï¿£ Â³ï¿£)ã¥',
            '(kyubey)': 'ï¼äººâ—• â€¿â€¿ â—•äººï¼¼', '(lambda)': 'Î»', '(lazy)': '_(:3ã€âˆ )_', '(left)': 'â†', '(<-)': 'â†',
            '(lenny)': '( Í¡Â° ÍœÊ– Í¡Â°)', '(lennybill)': '[Ì²Ì…$Ì²Ì…(Ì²Ì… Í¡Â° ÍœÊ– Í¡Â°Ì²Ì…)Ì²Ì…$Ì²Ì…]', '(lennyfight)': '(à¸‡ Í Â° ÍŸÊ– Í¡Â°)à¸‡',
            '(lennyflip)': '(ãƒ Í¡Â° ÍœÊ– Í¡Â°ãƒ) ï¸µ ( Íœã€‚ Í¡Ê– Íœã€‚)', '(lennygang)': '( Í¡Â°( Í¡Â° ÍœÊ–( Í¡Â° ÍœÊ– Í¡Â°)Ê– Í¡Â°) Í¡Â°)',
            '(lennyshrug)': 'Â¯\\_( Í¡Â° ÍœÊ– Í¡Â°)_/Â¯', '(lennysir)': '( à²  ÍœÊ– à²°à³ƒ)', '(lennystalker)': 'â”¬â”´â”¬â”´â”¤( Í¡Â° ÍœÊ–â”œâ”¬â”´â”¬â”´',
            '(lennystrong)': 'á•¦( Í¡Â° ÍœÊ– Í¡Â°)á•¤', '(lennywizard)': 'â•°( Í¡Â° ÍœÊ– Í¡Â° )ã¤â”€â”€â˜†*:ãƒ»ï¾Ÿ', '(loading)': 'â–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’',
            '(lol)': 'L(Â° O Â°L)', '(look)': '(à²¡_à²¡)â˜', '(loud)': 'á•¦(â©¾ï¹â©½)á•¥', '(noise)': 'á•¦(â©¾ï¹â©½)á•¥',
            '(love)': 'â™¥â€¿â™¥', '(lovebear)': 'Ê•â™¥á´¥â™¥Ê”', '(lumpy)': 'ê’° ê’¡âŒ“ê’¡ê’±', '(luv)': '-`áƒ¦Â´-',
            '(magic)': 'ãƒ½(ï½€Ğ”Â´)âŠƒâ”â˜†ï¾Ÿ. * ï½¥ ï½¡ï¾Ÿ,', '(magicflip)': '(/Â¯â—¡ â€¿ â—¡)/Â¯ ~ â”»â”â”»', '(meep)': '\\(Â°^Â°)/',
            '(meh)': 'à² _à² ', '(metal)': '\\m/,(> . <)_\\m/', '(rock)': '\\m/,(> . <)_\\m/', '(mistyeyes)': 'à²¡_à²¡',
            '(monster)': 'à¼¼ à¼àº¶ à·´ à¼àº¶à¼½', '(natural)': 'â™®', '(needle)': 'â”Œ(â—‰ ÍœÊ–â—‰)ã¤â”£â–‡â–‡â–‡â•â”€â”€',
            '(inject)': 'â”Œ(â—‰ ÍœÊ–â—‰)ã¤â”£â–‡â–‡â–‡â•â”€â”€', '(nerd)': '(âŒâŠ™_âŠ™)', '(nice)': '( Í¡Â° Íœ Â°)', '(no)': 'â†’_â†',
            '(noclue)': 'ï¼äººâ—• __ â—•äººï¼¼', '(nom)': '(ã£Ë†Ú¡Ë†Ï‚)', '(yummy)': '(ã£Ë†Ú¡Ë†Ï‚)', '(delicious)': '(ã£Ë†Ú¡Ë†Ï‚)',
            '(note)': 'â™«', '(sing)': 'â™«', '(nuclear)': 'â˜¢', '(radioactive)': 'â˜¢', '(nukular)': 'â˜¢',
            '(nyan)': '~=[,,_,,]:3', '(nyeh)': '@^@', '(ohshit)': '( Âºï¹ƒÂº )', '(omega)': 'Î©', '(omg)': 'â—•_â—•',
            '(1/8)': 'â…›', '(1/4)': 'Â¼', '(1/2)': 'Â½', '(1/3)': 'â…“', '(opt)': 'âŒ¥', '(option)': 'âŒ¥', '(orly)': '(ëˆˆ_ëˆˆ)',
            '(ohyou)': '(â—à°¥à±ªà°¥)á´–', '(ou)': '(â—à°¥à±ªà°¥)á´–', '(peace)': 'âœŒ(-â€¿-)âœŒ', '(victory)': 'âœŒ(-â€¿-)âœŒ',
            '(pear)': '(__>-', '(pi)': 'Ï€', '(pingpong)': '( â€¢_â€¢)O*Â¯`Â·.Â¸.Â·Â´Â¯`Â°Q(â€¢_â€¢ )', '(plain)': '._.',
            '(pleased)': '(Ë¶â€¾á·„ â»Ì« â€¾á·…Ëµ)', '(point)': '(â˜ï¾Ÿãƒ®ï¾Ÿ)â˜', '(pooh)': 'Ê• â€¢ÌØˆâ€¢Ì€)', '(porcupine)': '(â€¢á´¥â€¢ )Ì`Ì\'Ì`Ì\'Ìâ»',
            '(pound)': 'Â£', '(praise)': '(â˜ Õà¨Š Õ)â˜', '(punch)': 'O=(\'-\'Q)', '(rage)': 't(à² ç›Šà² t)',
            '(mad)': 't(à² ç›Šà² t)', '(rageflip)': '(ãƒà² ç›Šà² )ãƒå½¡â”»â”â”»', '(rainbowcat)': '(=^ï½¥ï½ªï½¥^=))ï¾‰å½¡â˜†',
            '(really)': 'Ã²_Ã´', '(r)': 'Â®', '(right)': 'â†’', '(->)': 'â†’', '(riot)': 'à­§à¼¼à² ç›Šà² à¼½à­¨', '(rolldice)': 'âšƒ',
            '(rolleyes)': '(â—”_â—”)', '(rose)': 'âœ¿Ú¿Ú°Û£â€”', '(run)': '(â•¯Â°â–¡Â°)â•¯', '(sad)': 'Îµ(Â´×¡Ö¼ï¸µ×¡Ö¼`)Ğ·',
            '(saddonger)': 'ãƒ½à¼¼àºˆÊ–Ì¯àºˆà¼½ï¾‰', '(sadlenny)': '( Í¡Â° Ê–Ì¯ Í¡Â°)', '(7/8)': 'â…', '(sharp)': 'â™¯', '(diesis)': 'â™¯',
            '(shout)': 'â•š(â€¢âŒ‚â€¢)â•', '(shrug)': 'Â¯\\_(ãƒ„)_/Â¯', '(shy)': '=^_^=', '(sigma)': 'Î£', '(sum)': 'Î£',
            '(skull)': 'â˜ ', '(smile)': 'ãƒ„', '(smiley)': 'â˜ºï¸', '(smirk)': 'Â¬â€¿Â¬', '(snowman)': 'â˜ƒ',
            '(sob)': '(;Â´à¼àº¶Ğ”à¼àº¶`)', '(soviettableflip)': 'ãƒâ”¬â”€â”¬ãƒ ï¸µ ( \\oÂ°o)\\', '(spade)': 'â™ ', '(sqrt)': 'âˆš',
            '(squid)': '<ã‚³:å½¡', '(star)': 'â˜…', '(strong)': 'á•™(â‡€â€¸â†¼â€¶)á•—', '(suicide)': 'Îµ/ÌµÍ‡Ì¿Ì¿/â€™Ì¿â€™Ì¿ Ì¿(â—¡ï¸µâ—¡)',
            '(sum)': 'âˆ‘', '(sun)': 'â˜€', '(surprised)': '(à¹‘â€¢Ì ãƒ® â€¢Ì€à¹‘)', '(surrender)': '\\_(-_-)_/',
            '(stalker)': 'â”¬â”´â”¬â”´â”¤(ï½¥_â”œâ”¬â”´â”¬â”´', '(swag)': '(Ì¿â–€Ì¿â€¿â€‰Ì¿â–€Ì¿ Ì¿)', '(sword)': 'o()xxxx[{::::::::::::::::::>',
            '(tabledown)': 'â”¬â”€â”¬ï»¿ ãƒ( ã‚œ-ã‚œãƒ)', '(tableflip)': '(ãƒ ã‚œĞ”ã‚œ)ãƒ ï¸µ â”»â”â”»', '(tau)': 'Ï„', '(tears)': '(à²¥ï¹à²¥)',
            '(terrorist)': 'à­§à¼¼à² ç›Šà² à¼½ï¸»â•¦â•¤â”€', '(thanks)': '\\(^-^)/', '(thankyou)': '\\(^-^)/', '(ty)': '\\(^-^)/',
            '(therefore)': 'â¸«', '(so)': 'â¸«', '(this)': '( Í¡Â° ÍœÊ– Í¡Â°)_/Â¯', '(3/8)': 'â…œ', '(tiefighter)': '|=-(Â¤)-=|',
            '(tired)': '(=____=)', '(toldyouso)': 'â˜œ(ê’¡âŒ“ê’¡)', '(toldyou)': 'â˜œ(ê’¡âŒ“ê’¡)', '(toogood)': 'á•¦(Ã²á´¥Ã³)á•¥',
            '(tm)': 'â„¢', '(triangle)': 'â–²', '(t)': 'â–²', '(2/3)': 'â…”', '(unflip)': 'â”¬â”€â”€â”¬ ãƒ(Ã²_Ã³ãƒ)', '(up)': 'â†‘',
            '(victory)': '(à¹‘â€¢Ì€ã…‚â€¢Ì)à¸‡âœ§', '(wat)': '(Ã’Ğ”Ã“×±)', '(wave)': '( * ^ *) ãƒã‚·', '(whaa)': 'Ã–',
            '(whistle)': '(ã£^Ğ·^)â™ªâ™¬', '(whoa)': '(Â°oâ€¢)', '(why)': 'áƒš(`â—‰â—à±ªâ—Ÿâ—‰â€µáƒš)',
            '(witchtext)': 'WHÎ£Ğ˜ $HÎ›LL WÎ£ â€ HĞ¯Î£Î£ MÎ£Î£â€  Î›GÎ›|Ğ˜?', '(woo)': 'ï¼¼(ï¼¾Oï¼¾)ï¼', '(wtf)': '(âŠ™ï¼¿âŠ™\')',
            '(wut)': 'âŠ™Ï‰âŠ™', '(yay)': '\\( ï¾Ÿãƒ®ï¾Ÿ)/', '(yeah)': '(â€¢Ì€á´—â€¢Ì)Ùˆ Ì‘Ì‘', '(yes)': '(â€¢Ì€á´—â€¢Ì)Ùˆ Ì‘Ì‘', '(yen)': 'Â¥',
            '(yinyang)': 'â˜¯', '(yy)': 'â˜¯', '(yolo)': 'Yáµ’áµ˜ Oá¶°Ë¡Ê¸ Lá¶¤áµ›áµ‰ Oá¶°á¶œáµ‰', '(youkids)': 'áƒšà¼¼>â•­ ÍŸÊ–â•®<à¼½áƒš',
            '(ukids)': 'áƒšà¼¼>â•­ ÍŸÊ–â•®<à¼½áƒš', '(y u no)': '(å±®ï¾ŸĞ”ï¾Ÿ)å±® Y U NO', '(yuno)': '(å±®ï¾ŸĞ”ï¾Ÿ)å±® Y U NO',
            '(zen)': 'âŠ¹â•°(âŒ£ÊŸâŒ£)â•¯âŠ¹', '(meditation)': 'âŠ¹â•°(âŒ£ÊŸâŒ£)â•¯âŠ¹', '(omm)': 'âŠ¹â•°(âŒ£ÊŸâŒ£)â•¯âŠ¹',
            '(zoidberg)': '(V) (Â°,,,,Â°) (V)', '(zombie)': '[Â¬Âº-Â°]Â¬'
        };

        // --- Sound System ---
        const SoundSys = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone: function(freq, type, duration, vol=0.1) {
                if (state.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            click: function() { this.playTone(800, 'square', 0.05, 0.05); },
            blip: function() { this.playTone(1200, 'sine', 0.15, 0.1); },
            alert: function() { 
                this.playTone(1500, 'square', 0.1, 0.2); 
                setTimeout(() => this.playTone(1500, 'square', 0.1, 0.2), 150);
            }
        };

        // --- Theme System ---
        const Themes = {
            green: { main: '#33ff00', system: '#ffaa00', chat: '#00ccff', error: '#ff3333', radio: '#ff33cc' },
            amber: { main: '#ffb000', system: '#ffcc00', chat: '#ffb000', error: '#ff5500', radio: '#ff8800' },
            blue:  { main: '#0088ff', system: '#00aaff', chat: '#00ffff', error: '#ff3333', radio: '#cc00ff' },
            white: { main: '#e0e0e0', system: '#ffffff', chat: '#cccccc', error: '#ff3333', radio: '#ff00ff' },
            matrix: { main: '#00ff41', system: '#008f11', chat: '#003b00', error: '#ff3333', radio: '#00ff00' }
        };

        function applyTheme(themeName) {
            const theme = Themes[themeName];
            if (!theme) return false;
            const r = document.documentElement;
            r.style.setProperty('--terminal-main', theme.main);
            r.style.setProperty('--terminal-glow', theme.main);
            r.style.setProperty('--system-color', theme.system);
            r.style.setProperty('--chat-color', theme.chat);
            r.style.setProperty('--error-color', theme.error);
            return true;
        }

        // --- UI References ---
        const input = document.getElementById('command-input');
        const inputLineContainer = document.getElementById('input-line-container');
        const history = document.getElementById('chat-history');
        const container = document.getElementById('terminal-container');
        const promptSpan = document.getElementById('prompt-span');
        const cmdBefore = document.getElementById('cmd-before');
        const cmdCursor = document.getElementById('cmd-cursor');
        const cmdAfter = document.getElementById('cmd-after');
        const autocompleteMenu = document.getElementById('autocomplete-menu');
        const fileInput = document.getElementById('file-upload'); 
        const tabBtn = document.getElementById('tab-btn');
        
        // Overlays
        const editorOverlay = document.getElementById('profile-editor-overlay');
        const postEditorOverlay = document.getElementById('post-editor-overlay');
        const profileViewerOverlay = document.getElementById('profile-viewer-overlay');
        const postReaderOverlay = document.getElementById('post-reader-overlay');
        const crtOverlay = document.getElementById('crt-overlay');

        // Profile Editor Refs
        const editNick = document.getElementById('edit-nick');
        const editBio = document.getElementById('edit-bio');
        const editAvatar = document.getElementById('edit-avatar');
        
        // Post Editor Refs
        const postEditTitle = document.getElementById('post-edit-title');
        const postEditImg = document.getElementById('post-edit-img');
        const postEditBody = document.getElementById('post-edit-body');
        let postEditorImageAscii = null;

        // Profile Viewer Refs
        const pvBioSection = document.getElementById('pv-bio-section');
        const pvPostList = document.getElementById('pv-post-list');
        
        // Reader Refs
        const readerContent = document.getElementById('reader-content');

        // Editor Selection State
        const editorElements = [
            document.getElementById('row-nick'), 
            document.getElementById('row-bio'), 
            document.getElementById('row-avatar'),
            document.getElementById('btn-save'),
            document.getElementById('btn-cancel')
        ];
        
        // Post Editor Selection State
        const postEditorElements = [
            document.getElementById('p-row-title'),
            document.getElementById('p-row-img'),
            document.getElementById('post-edit-body'),
            document.getElementById('btn-post-submit'),
            document.getElementById('btn-post-cancel')
        ];

        let editorSelection = 0;
        let editorIsEditing = false;
        let editorBuffer = '';
        let editorAvatarBuffer = null;
        let currentViewingPosts = []; // For storing post data in viewer

        function updateInputDisplay() {
            // Don't update main input display if in any overlay mode
            if (['PROFILE_EDIT', 'POST_EDIT', 'PROFILE_VIEW', 'READER'].includes(state.mode)) return;

            const val = input.value;
            const selStart = input.selectionStart || 0;
            const left = val.substring(0, selStart);
            const char = val.substring(selStart, selStart + 1) || '\u00A0';
            const right = val.substring(selStart + 1);

            cmdBefore.textContent = left;
            cmdCursor.textContent = char;
            cmdAfter.textContent = right;
        }

        ['input', 'click', 'focus', 'blur'].forEach(evt => {
            input.addEventListener(evt, () => requestAnimationFrame(updateInputDisplay));
        });

        // --- Tab Button Logic ---
        tabBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (['PROFILE_EDIT', 'POST_EDIT'].includes(state.mode)) {
                 handleOverlayKey({ key: 'Tab', preventDefault: () => {} });
            } else {
                input.focus(); 
                handleTabCompletion({ preventDefault: () => {} });
            }
        });

        // --- File Upload Handler ---
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            // PROFILE EDITOR
            if (state.mode === 'PROFILE_EDIT') {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                         const ascii = await convertImageToAscii(event.target.result);
                         editorAvatarBuffer = ascii;
                         editAvatar.textContent = "[ IMAGE SET (ASCII GENERATED) ]";
                    } catch(e) {
                         editAvatar.textContent = "[ ERROR CONVERTING ]";
                    }
                    fileInput.value = '';
                };
                reader.readAsDataURL(file);
                return;
            }
            
            // POST EDITOR
            if (state.mode === 'POST_EDIT') {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                         const ascii = await convertImageToAscii(event.target.result);
                         postEditorImageAscii = ascii;
                         postEditImg.textContent = "[ IMAGE ATTACHED ]";
                    } catch(e) {
                         postEditImg.textContent = "[ ERROR CONVERTING ]";
                    }
                    fileInput.value = '';
                };
                reader.readAsDataURL(file);
                return;
            }
            
            // NORMAL CHAT MODE
            addMessage('SYSTEM', `PROCESSING IMAGE: ${file.name}...`, true);
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const ascii = await convertImageToAscii(event.target.result);
                    if (state.mode === 'COMMAND') {
                        addMessage(null, ascii, false, false, false, true);
                    } else {
                        await sendMessage(ascii, true, false); 
                    }
                } catch(err) {
                    addMessage('ERROR', 'CONVERSION FAILED: ' + err.message, false, false, true);
                }
                fileInput.value = ''; 
            };
            reader.readAsDataURL(file);
        });

        // --- Autocomplete Logic ---
        function showAutocompleteMenu(options) {
            autocompleteMenu.innerHTML = '';
            autocompleteOptions = options;
            autocompleteIndex = -1;

            if (options.length === 0) {
                autocompleteMenu.style.display = 'none';
                return;
            }

            options.forEach((opt, index) => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.textContent = opt;
                div.onclick = () => confirmSelection(opt);
                autocompleteMenu.appendChild(div);
            });

            autocompleteMenu.style.display = 'flex';
        }

        function hideAutocomplete() {
            autocompleteMenu.style.display = 'none';
            autocompleteOptions = [];
            autocompleteIndex = -1;
        }

        function highlightOption(index) {
            const items = autocompleteMenu.children;
            for (let i = 0; i < items.length; i++) {
                items[i].classList.remove('selected');
            }
            if (index >= 0 && index < items.length) {
                items[index].classList.add('selected');
                items[index].scrollIntoView({ block: 'nearest' });
            }
        }

        function confirmSelection(selectedValue) {
            const val = input.value;
            const lastSpaceIdx = val.lastIndexOf(' ');
            
            if (lastSpaceIdx === -1) {
                input.value = selectedValue + ' ';
            } else {
                const prefix = val.substring(0, lastSpaceIdx + 1);
                input.value = prefix + selectedValue + ' ';
            }
            
            hideAutocomplete();
            updateInputDisplay();
            input.focus();
        }

        function handleTabCompletion(e) {
            e.preventDefault();

            if (autocompleteMenu.style.display === 'flex') {
                autocompleteIndex = (autocompleteIndex + 1) % autocompleteOptions.length;
                highlightOption(autocompleteIndex);
                return;
            }

            const val = input.value;
            let matches = [];

            // Standard command/emoji completion based on space splitting
            const parts = val.split(' '); 
            const currentWord = parts[parts.length - 1]; 

            if (currentWord.startsWith('(')) {
                const emojiKeys = Object.keys(EMOJI_MAP);
                matches = emojiKeys.filter(key => key.startsWith(currentWord));
            }
            else if (parts.length === 1 && currentWord !== "") {
                    matches = commandsList.filter(cmd => cmd.startsWith(currentWord));
            }
            else if (parts.length === 2 && !currentWord.startsWith('(')) {
                const cmd = parts[0];
                if (subCommands[cmd]) {
                    matches = subCommands[cmd].filter(sub => sub.startsWith(currentWord));
                }
            }

            if (matches.length === 1) {
                confirmSelection(matches[0]);
            } else if (matches.length > 1) {
                showAutocompleteMenu(matches);
            }
        }

        // --- Boot Sequence & Auth ---
        
        const bootText = [
            "BIOS DATE 01/01/99 14:22:55 VER 1.0.2",
            "CPU: NEC V60, SPEED: 33MHz",
            "640K RAM SYSTEM... OK",
            "LOADING T-OS KERNEL...",
            "MOUNTING VIRTUAL FILESYSTEM... OK",
            "INITIATING NETWORK PROTOCOLS...",
            "  > TCP/IP... UP",
            "  > FIREWALL... ACTIVE",
            "  > ENCRYPTION... ENABLED",
            "CONNECTING TO SATELLITE UPLINK...",
            "CONNECTION ESTABLISHED.",
            "STARTING T-CHAT INTERFACE..."
        ];

        async function runBootSequence() {
            // Attempt to initialize audio context
            SoundSys.init();

            // Wait a moment for effect
            await new Promise(r => setTimeout(r, 800));
            
            for (const line of bootText) {
                // Play text sound
                SoundSys.click();
                
                addMessage(null, line, true); 
                // Random typing delay
                await new Promise(r => setTimeout(r, 100 + Math.random() * 250));
            }
            
            // Final pause before clear
            await new Promise(r => setTimeout(r, 1000));
            
            history.innerHTML = '';
            state.booting = false;
            
            // Show UI
            inputLineContainer.style.opacity = '1';
            input.focus();
            showWelcomeScreen();
        }

        function showWelcomeScreen() {
            const logo = `
  _______   _____ _           _   
 |__   __| / ____| |         | |  
    | |   | |    | |__   __ _| |_ 
    | |   | |    | '_ \\ / _\` | __|
    | |   | |____| | | | (_| | |_ 
    |_|    \\_____|_| |_|\\__,_|\\__|  v2.0
            `;
            addMessage(null, logo, false, false, false, true); // Ascii art mode

            addMessage('SYSTEM', 'WELCOME, USER.', true);
            addMessage(null, '------------------------------------------------');
            addMessage(null, 'QUICK START GUIDE:');
            addMessage(null, '1. LOGIN:        Type "login" to sign in with Google.');
            addMessage(null, '2. COMMANDS:     Type "help" to see available tools.');
            addMessage(null, '3. POSTING:      Type "post" to write a blog entry.');
            addMessage(null, '4. PROFILES:     Type "profile [email]" to view users.');
            addMessage(null, '------------------------------------------------');
            
            if (currentUser && !currentUser.isAnonymous) {
                addMessage('SYSTEM', `SESSION RESTORED: ${currentUser.email}`, true);
            }
            
            addMessage('SYSTEM', 'SYSTEM READY. AWAITING INPUT...', true);
        }

        const initGuestAuth = async () => {
            try { await signInAnonymously(auth); } 
            catch (e) { console.warn("Guest login failed:", e.code); }
        };

        const updateStatus = async (status) => {
            if (!currentUser || currentUser.isAnonymous) return;
            try {
                const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', currentUser.uid);
                await setDoc(userRef, {
                    status: status,
                    lastSeen: serverTimestamp()
                }, { merge: true });
                return true;
            } catch(e) { console.error(e); return false; }
        };

        // --- Notification Listener ---
        function setupNotificationListener(uid) {
            if (notificationUnsubscribe) notificationUnsubscribe();
            
            const notifRef = collection(db, 'artifacts', appId, 'users', uid, 'notifications');
            const q = query(notifRef, orderBy('timestamp', 'desc'), limit(1));
            
            notificationUnsubscribe = onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added") {
                        const notif = change.doc.data();
                        if (notif.timestamp && (Date.now() - notif.timestamp.toMillis()) < 30000) {
                            triggerNotificationEffect(notif);
                        }
                    }
                });
            });
        }

        function triggerNotificationEffect(notif) {
            SoundSys.alert();
            crtOverlay.classList.add('notification-flash');
            setTimeout(() => crtOverlay.classList.remove('notification-flash'), 500);
            addMessage('ALERT', `MENTIONED BY [${notif.fromName}]: "${notif.preview}"`, true);
        }

        onAuthStateChanged(auth, async (user) => {
            currentUser = user;
            if (user) {
                if (user.isAnonymous) {
                     updatePrompt('guest');
                     if (!state.booting) addMessage('SYSTEM', 'GUEST MODE ACTIVE.', true);
                } else {
                    updatePrompt(user.email.split('@')[0]);
                    if (!state.booting) addMessage('SYSTEM', `AUTHENTICATED AS ${user.email}`, true);
                    
                    await updateStatus('online');
                    setupNotificationListener(user.uid);

                    try {
                        const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', user.uid);
                        const snap = await getDoc(userRef);
                        const baseData = {
                            email: user.email,
                            displayName: user.displayName || user.email.split('@')[0],
                            uid: user.uid,
                            status: 'online',
                            lastSeen: serverTimestamp()
                        };
                        
                        if (!snap.exists() || !snap.data().joinedAt) {
                            baseData.joinedAt = serverTimestamp();
                        }
                        
                        await setDoc(userRef, baseData, { merge: true });
                    } catch (e) {}
                }
            } else {
                updatePrompt('offline');
                initGuestAuth();
                if (notificationUnsubscribe) notificationUnsubscribe();
            }
        });

        // Trigger Boot
        window.onload = runBootSequence;

        const handleLogin = async () => {
            try {
                addMessage('SYSTEM', 'INITIATING GOOGLE AUTH HANDSHAKE...', true);
                const provider = new GoogleAuthProvider();
                await signInWithPopup(auth, provider);
            } catch (error) {
                if (error.code === 'auth/unauthorized-domain') {
                    addMessage('ERROR', 'DOMAIN NOT AUTHORIZED. Check Firebase Console.', false, false, true);
                } else {
                    addMessage('ERROR', `LOGIN FAILED: ${error.message}`, false, false, true);
                }
            }
        };

        function updatePrompt(username) {
            if (state.mode === 'CHAT') {
                const name = currentChatPartner.nickname || currentChatPartner.email;
                promptSpan.textContent = `[CHAT:${name}] >`;
                input.style.caretColor = 'var(--chat-color)';
            } else {
                promptSpan.textContent = `${username}@TChat:~$`;
                input.style.caretColor = 'var(--terminal-main)';
            }
        }

        // --- Effects ---
        function parseEmojis(text) {
             return text.replace(/\([^)]+\)/g, (match) => EMOJI_MAP[match] || match);
        }

        function scrambleText(element, finalValidText, finalHTML = null) {
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()";
            let iterations = 0;
            const originalText = finalValidText;
            
            const interval = setInterval(() => {
                element.innerText = originalText.split('').map((char, index) => {
                    if (char === ' ' || char === '\n') return char; 
                    if (index < Math.floor(iterations)) return originalText[index];
                    return chars[Math.floor(Math.random() * chars.length)];
                }).join('');
                
                if (iterations >= originalText.length) {
                    clearInterval(interval);
                    if (finalHTML) {
                        element.innerHTML = finalHTML;
                    } else {
                        element.innerText = originalText;
                    }
                }
                
                iterations += 1/3 + (originalText.length / 300); 
            }, 60); 
        }

        const msgMap = new Map();

        function addMessage(sender, text, isSystem = false, isChat = false, isError = false, isAscii = false, msgId = null, isBurn = false) {
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('message-line');
            if (isSystem) msgDiv.classList.add('system-msg');
            if (isChat) msgDiv.classList.add('chat-msg');
            if (isError) msgDiv.classList.add('error-msg');
            if (isAscii) msgDiv.classList.add('ascii-art');

            if (msgId) {
                msgDiv.setAttribute('data-msg-id', msgId);
                msgMap.set(msgId, msgDiv);
            }

            if (!state.muted && (isSystem || (isChat && sender !== 'ME'))) {
                setTimeout(() => SoundSys.blip(), 50);
            }

            const contentSpan = document.createElement('span');

            if (sender) {
                let prefixColor = 'var(--terminal-main)';
                if (isChat) {
                    prefixColor = (sender === 'ME') ? 'var(--terminal-main)' : 'var(--chat-color)';
                }
                if (isSystem) prefixColor = 'var(--system-color)';
                if (isError) prefixColor = 'var(--error-color)';
                
                const prefixSpan = document.createElement('span');
                prefixSpan.className = 'user-prefix';
                prefixSpan.style.color = prefixColor;
                prefixSpan.textContent = `[${sender}]: `;
                msgDiv.appendChild(prefixSpan);
            }

            let finalHTML = null;
            if (!isAscii && text) {
                let html = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                html = html.replace(/@\((.*?)\)/g, '<span class="highlight-mention">@($1)</span>');
                contentSpan.innerHTML = html;
                finalHTML = html;
            } else {
                contentSpan.textContent = text; 
            }

            msgDiv.appendChild(contentSpan);

            if (isBurn) {
                const burnSpan = document.createElement('span');
                burnSpan.className = 'burn-timer';
                burnSpan.textContent = ' [10s]';
                msgDiv.appendChild(burnSpan);

                let left = 10;
                const timer = setInterval(() => {
                    left--;
                    if(left >= 0) burnSpan.textContent = ` [${left}s]`;
                    else {
                        clearInterval(timer);
                    }
                }, 1000);
            }

            history.appendChild(msgDiv);
            scrollToBottom();

            if ((isChat && sender !== 'ME') || isSystem) {
                if (!isAscii) scrambleText(contentSpan, text, finalHTML);
            }

            return msgDiv;
        }

        function scrollToBottom() {
            history.scrollTop = history.scrollHeight;
        }

        // --- Keyboard Handling for Overlays ---
        document.addEventListener('keydown', (event) => {
            if (['PROFILE_EDIT', 'POST_EDIT'].includes(state.mode)) {
                handleOverlayKey(event);
                return;
            }
            if (state.mode === 'PROFILE_VIEW') {
                handleProfileViewerKey(event);
                return;
            }
            if (state.mode === 'READER') {
                if (event.key === 'Escape' || event.key === 'Enter') {
                    closePostReader();
                }
                return;
            }
        });

        input.addEventListener('keydown', function(event) {
            if (state.mode !== 'COMMAND' && state.mode !== 'CHAT') return; // Don't type if in overlay

            SoundSys.init();
            
            if (event.key === 'Tab') {
                handleTabCompletion(event);
                return; 
            }

            if (autocompleteMenu.style.display === 'flex') {
                if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    autocompleteIndex = (autocompleteIndex - 1 + autocompleteOptions.length) % autocompleteOptions.length;
                    highlightOption(autocompleteIndex);
                    return;
                }
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    autocompleteIndex = (autocompleteIndex + 1) % autocompleteOptions.length;
                    highlightOption(autocompleteIndex);
                    return;
                }
                if (event.key === 'Enter') {
                    if (autocompleteIndex >= 0) {
                        event.preventDefault();
                        confirmSelection(autocompleteOptions[autocompleteIndex]);
                        return;
                    }
                    hideAutocomplete();
                }
                if (event.key === 'Escape') {
                    hideAutocomplete();
                    return;
                }
            } else {
                if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    if (cmdHistory.length > 0) {
                        if (historyIndex < cmdHistory.length - 1) {
                            historyIndex++;
                            input.value = cmdHistory[cmdHistory.length - 1 - historyIndex];
                            updateInputDisplay();
                        }
                    }
                    return;
                }
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        input.value = cmdHistory[cmdHistory.length - 1 - historyIndex];
                    } else if (historyIndex === 0) {
                        historyIndex = -1;
                        input.value = '';
                    }
                    updateInputDisplay();
                    return;
                }
            }

            if (event.key.length === 1 || event.key === 'Backspace') {
                 if (event.key !== 'Tab') hideAutocomplete();
            }

            if (!['Enter', 'Shift', 'Control', 'Alt', 'ArrowUp', 'ArrowDown', 'Tab'].includes(event.key)) {
                SoundSys.click();
            }

            if (event.key === 'Enter') {
                const text = input.value; 
                const trimmed = text.trim();
                
                if (event.shiftKey) return;

                if (trimmed !== "") {
                    cmdHistory.push(trimmed);
                    historyIndex = -1;

                    if (state.mode === 'COMMAND') {
                        addMessage('ME', trimmed);
                        processCommand(trimmed);
                    } else {
                        processChatInput(trimmed);
                    }
                    input.value = '';
                    updateInputDisplay();
                }
                event.preventDefault(); 
            }
            requestAnimationFrame(updateInputDisplay);
        });

        document.addEventListener('click', (e) => { 
            if (state.mode !== 'COMMAND' && state.mode !== 'CHAT') return; // Don't focus input if in overlay

            input.focus(); 
            SoundSys.init();
            if (e.target !== autocompleteMenu && e.target.parentElement !== autocompleteMenu && e.target !== tabBtn) {
                hideAutocomplete();
            }
        });

        // --- Profile Editor Logic ---
        function openProfileEditor() {
            if (!ensureAuth()) return;
            state.mode = 'PROFILE_EDIT';
            editorOverlay.style.display = 'flex';
            
            const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', currentUser.uid);
            getDoc(userRef).then(snap => {
                if(snap.exists()) {
                    const d = snap.data();
                    editNick.textContent = d.displayName || '';
                    editBio.textContent = d.bio || '';
                    if (d.avatarAscii) {
                        editorAvatarBuffer = d.avatarAscii;
                        editAvatar.textContent = "[ IMAGE SET ]";
                    }
                }
            });

            editorSelection = 0;
            editorIsEditing = false;
            updateEditorVisuals(editorElements, editorSelection);
            
            // Attach clicks
            document.getElementById('row-nick').onclick = () => handleEditorInteraction(0, 'PROFILE');
            document.getElementById('row-bio').onclick = () => handleEditorInteraction(1, 'PROFILE');
            document.getElementById('row-avatar').onclick = () => handleEditorInteraction(2, 'PROFILE');
            document.getElementById('btn-save').onclick = () => handleEditorInteraction(3, 'PROFILE');
            document.getElementById('btn-cancel').onclick = () => handleEditorInteraction(4, 'PROFILE');
        }

        function closeProfileEditor() {
            state.mode = 'COMMAND';
            editorOverlay.style.display = 'none';
            editorIsEditing = false;
            input.focus();
        }

        async function saveProfileEditor() {
            addMessage('SYSTEM', 'SAVING PROFILE...', true);
            const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', currentUser.uid);
            
            const dataToUpdate = {
                displayName: editNick.textContent.trim(),
                bio: editBio.textContent.trim(),
            };
            
            if (editorAvatarBuffer) {
                dataToUpdate.avatarAscii = editorAvatarBuffer;
            }
            
            await setDoc(userRef, dataToUpdate, { merge: true });
            
            addMessage('SYSTEM', 'PROFILE UPDATED.', true);
            closeProfileEditor();
        }

        // --- Post Editor Logic ---
        function openPostEditor() {
            if (!ensureAuth()) return;
            state.mode = 'POST_EDIT';
            postEditorOverlay.style.display = 'flex';
            
            // Clear fields
            postEditTitle.textContent = '';
            postEditImg.textContent = '[ CLICK TO UPLOAD IMAGE ]';
            postEditBody.value = '';
            postEditorImageAscii = null;

            editorSelection = 0;
            editorIsEditing = false;
            updateEditorVisuals(postEditorElements, editorSelection);

            // Attach clicks
            document.getElementById('p-row-title').onclick = () => handleEditorInteraction(0, 'POST');
            document.getElementById('p-row-img').onclick = () => handleEditorInteraction(1, 'POST');
            // Textarea click handled natively? We need to set active class though
            postEditBody.onclick = () => { editorSelection = 2; updateEditorVisuals(postEditorElements, editorSelection); };
            document.getElementById('btn-post-submit').onclick = () => handleEditorInteraction(3, 'POST');
            document.getElementById('btn-post-cancel').onclick = () => handleEditorInteraction(4, 'POST');
        }

        function closePostEditor() {
            state.mode = 'COMMAND';
            postEditorOverlay.style.display = 'none';
            input.focus();
        }

        async function savePost() {
            const title = postEditTitle.textContent.trim();
            const body = postEditBody.value.trim();
            
            if (!title || title === "[ ENTER TITLE ]") {
                alert("TITLE REQUIRED"); // Simple alert for overlay
                return;
            }
            if (!body) {
                alert("CONTENT REQUIRED");
                return;
            }

            addMessage('SYSTEM', 'TRANSMITTING POST...', true);
            closePostEditor(); // Close first

            try {
                const postsRef = collection(db, 'artifacts', appId, 'public', 'data', 'posts');
                await addDoc(postsRef, {
                    title: title,
                    content: body,
                    asciiArt: postEditorImageAscii,
                    authorId: currentUser.uid,
                    authorEmail: currentUser.email,
                    authorName: currentUser.displayName || currentUser.email.split('@')[0],
                    timestamp: serverTimestamp()
                });
                addMessage('SYSTEM', 'POST PUBLISHED SUCCESSFULLY.', true);
            } catch(e) {
                addMessage('ERROR', 'PUBLISH FAILED: ' + e.message, false, false, true);
            }
        }

        // --- Profile Viewer Logic ---
        async function openProfileViewer(identifier) {
            state.mode = 'PROFILE_VIEW';
            profileViewerOverlay.style.display = 'flex';
            pvBioSection.innerHTML = 'LOADING DATA...';
            pvPostList.innerHTML = 'SCANNING ARCHIVES...';
            currentViewingPosts = [];
            editorSelection = 0; // 0 for close button, 1+ for posts

            try {
                let targetUser = null;
                
                // 1. Resolve User
                if (!identifier || identifier === 'me') {
                    // Current User
                    const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', currentUser.uid);
                    const snap = await getDoc(userRef);
                    if (snap.exists()) targetUser = snap.data();
                } else {
                    // Lookup
                    targetUser = await resolveUserByNickOrEmail(identifier);
                }

                if (!targetUser) {
                    pvBioSection.innerHTML = 'USER NOT FOUND.';
                    pvPostList.innerHTML = '';
                    return;
                }

                // Render Bio
                let asciiHtml = targetUser.avatarAscii ? `<div class="ascii-art" style="font-size:0.5rem;">${targetUser.avatarAscii}</div>` : '';
                pvBioSection.innerHTML = `
                    ${asciiHtml}
                    <div><strong>USER:</strong> ${targetUser.displayName || targetUser.email}</div>
                    <div><strong>STATUS:</strong> ${(targetUser.status || 'UNKNOWN').toUpperCase()}</div>
                    <div style="margin-top:5px; white-space:pre-wrap;">${targetUser.bio || 'No bio available.'}</div>
                `;

                // Fetch Posts (Client-side filtering to avoid index issues)
                const postsRef = collection(db, 'artifacts', appId, 'public', 'data', 'posts');
                const q = query(postsRef, where('authorId', '==', targetUser.uid));
                const snap = await getDocs(q);
                
                currentViewingPosts = [];
                snap.forEach(doc => {
                    const d = doc.data();
                    d.id = doc.id;
                    currentViewingPosts.push(d);
                });

                // Sort by time descending
                currentViewingPosts.sort((a,b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0));

                if (currentViewingPosts.length === 0) {
                    pvPostList.innerHTML = 'NO LOGS FOUND.';
                } else {
                    pvPostList.innerHTML = '';
                    currentViewingPosts.forEach((post, index) => {
                        const div = document.createElement('div');
                        div.className = 'post-list-item';
                        if (index === 0) div.classList.add('selected'); // First item selected by default? No, close button is 0.
                        
                        const date = post.timestamp ? new Date(post.timestamp.seconds * 1000).toLocaleDateString() : 'Unknown';
                        div.innerHTML = `<span>${post.title}</span> <span class="post-date">${date}</span>`;
                        div.onclick = () => openPostReader(post);
                        pvPostList.appendChild(div);
                    });
                    
                    // Setup selection logic for Viewer
                    // 0 = Close Button
                    // 1..N = Posts
                    editorSelection = 1; // Start on first post if exists
                    updateProfileViewerSelection();
                }
                
                document.getElementById('btn-pv-close').onclick = closeProfileViewer;

            } catch(e) {
                pvBioSection.innerHTML = 'ERROR: ' + e.message;
            }
        }

        function closeProfileViewer() {
            state.mode = 'COMMAND';
            profileViewerOverlay.style.display = 'none';
            input.focus();
        }

        function updateProfileViewerSelection() {
            // Reset Close Button
            const closeBtn = document.getElementById('btn-pv-close');
            closeBtn.classList.remove('active');
            
            // Reset List
            const items = pvPostList.children;
            for(let i=0; i<items.length; i++) items[i].classList.remove('selected');

            if (editorSelection === 0) {
                closeBtn.classList.add('active');
            } else {
                const index = editorSelection - 1;
                if (index >= 0 && index < items.length) {
                    items[index].classList.add('selected');
                    items[index].scrollIntoView({block: 'nearest'});
                }
            }
        }

        function handleProfileViewerKey(e) {
            const maxIdx = currentViewingPosts.length; // 0 is close, 1..maxIdx are posts
            
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                editorSelection--;
                if (editorSelection < 0) editorSelection = maxIdx;
                updateProfileViewerSelection();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                editorSelection++;
                if (editorSelection > maxIdx) editorSelection = 0;
                updateProfileViewerSelection();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (editorSelection === 0) {
                    closeProfileViewer();
                } else {
                    const post = currentViewingPosts[editorSelection - 1];
                    if (post) openPostReader(post);
                }
            } else if (e.key === 'Escape') {
                closeProfileViewer();
            }
        }

        // --- Post Reader Logic ---
        function openPostReader(post) {
            state.mode = 'READER';
            postReaderOverlay.style.display = 'flex';
            
            const date = post.timestamp ? new Date(post.timestamp.seconds * 1000).toLocaleString() : 'Unknown Date';
            let asciiHtml = post.asciiArt ? `<div class="ascii-art" style="font-size:0.5rem; text-align:center;">${post.asciiArt}</div>` : '';
            
            readerContent.innerHTML = `
                <div class="reader-title">${post.title}</div>
                <div class="reader-meta">AUTHOR: ${post.authorName} | DATE: ${date}</div>
                ${asciiHtml}
                <div style="margin-top:20px; line-height:1.4;">${post.content}</div>
            `;
            
            document.getElementById('btn-reader-close').onclick = closePostReader;
        }

        function closePostReader() {
            // Return to Profile View
            state.mode = 'PROFILE_VIEW';
            postReaderOverlay.style.display = 'none';
        }

        // --- Generic Editor Interaction Handler ---
        function updateEditorVisuals(elements, selection) {
            elements.forEach(el => {
                if (el) el.classList.remove('active');
                if (el) el.classList.remove('editing');
            });
            const currentEl = elements[selection];
            if (currentEl) {
                currentEl.classList.add('active');
                if (editorIsEditing) currentEl.classList.add('editing');
            }
        }

        function handleOverlayKey(e) {
            if (editorIsEditing) return; // Allow typing in inputs

            const currentElements = state.mode === 'PROFILE_EDIT' ? editorElements : postEditorElements;

            if (e.key === 'Tab' || e.key === 'ArrowDown') {
                e.preventDefault();
                editorSelection = (editorSelection + 1) % currentElements.length;
                SoundSys.blip();
                updateEditorVisuals(currentElements, editorSelection);
            } else if (e.key === 'ArrowUp') {
                 e.preventDefault();
                 editorSelection = (editorSelection - 1 + currentElements.length) % currentElements.length;
                 SoundSys.blip();
                 updateEditorVisuals(currentElements, editorSelection);
            }
            else if (e.key === ' ' || e.key === 'Enter') {
                e.preventDefault();
                SoundSys.click();
                
                const type = state.mode === 'PROFILE_EDIT' ? 'PROFILE' : 'POST';
                handleEditorInteraction(editorSelection, type);
            }
        }

        function handleEditorInteraction(index, type) {
            editorSelection = index;
            const currentElements = type === 'PROFILE' ? editorElements : postEditorElements;
            updateEditorVisuals(currentElements, editorSelection);

            if (type === 'PROFILE') {
                if (index === 0) activateInlineInput(editNick);
                else if (index === 1) activateInlineInput(editBio);
                else if (index === 2) fileInput.click();
                else if (index === 3) saveProfileEditor();
                else if (index === 4) closeProfileEditor();
            } 
            else if (type === 'POST') {
                if (index === 0) activateInlineInput(postEditTitle);
                else if (index === 1) fileInput.click();
                else if (index === 2) postEditBody.focus(); // Textarea focus
                else if (index === 3) savePost();
                else if (index === 4) closePostEditor();
            }
        }

        function activateInlineInput(element) {
            if (element.querySelector('input')) return;
            editorIsEditing = true;
            const currentText = element.textContent;
            element.textContent = ''; 
            const inputEl = document.createElement('input');
            inputEl.type = 'text';
            inputEl.value = currentText === '[ ENTER TITLE ]' ? '' : currentText;
            inputEl.className = 'terminal-inline-input';
            
            inputEl.addEventListener('blur', () => {
                element.textContent = inputEl.value || (element === postEditTitle ? '[ ENTER TITLE ]' : '');
                editorIsEditing = false;
                const els = state.mode === 'PROFILE_EDIT' ? editorElements : postEditorElements;
                updateEditorVisuals(els, editorSelection);
            });
            inputEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') inputEl.blur();
                e.stopPropagation();
            });
            element.appendChild(inputEl);
            inputEl.focus();
        }

        // --- Generic Helpers ---
        async function resolveUserByNickOrEmail(identifier) {
            const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'user_profiles');
            let q = query(usersRef, where("email", "==", identifier));
            let snapshot = await getDocs(q);
            if (!snapshot.empty) return snapshot.docs[0].data();

            q = query(usersRef, where("displayName", "==", identifier));
            snapshot = await getDocs(q);
            if (!snapshot.empty) return snapshot.docs[0].data();
            return null;
        }

        async function fetchAscii(url) {
             const lowerUrl = url.toLowerCase();
             const isImage = /\.(jpg|jpeg|png|gif|webp)$/.test(lowerUrl);
             if (isImage) return await convertImageToAscii(url);
             const response = await fetch(url);
             if (!response.ok) throw new Error("Network error: " + response.status);
             return await response.text();
        }

        function convertImageToAscii(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = url;
                img.onload = () => {
                    const cols = 100; 
                    const charAspect = 0.5; 
                    const aspect = img.height / img.width;
                    const rows = Math.floor(cols * aspect * charAspect);
                    const canvas = document.createElement('canvas');
                    canvas.width = cols;
                    canvas.height = rows;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, cols, rows);
                    try {
                        const data = ctx.getImageData(0, 0, cols, rows).data;
                        let ascii = "";
                        const chars = " .'`^\",:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";
                        for (let y = 0; y < rows; y++) {
                            for (let x = 0; x < cols; x++) {
                                const i = (y * cols + x) * 4;
                                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                                const charIdx = Math.floor((brightness / 255) * (chars.length - 1));
                                ascii += chars[charIdx];
                            }
                            ascii += "\n";
                        }
                        resolve(ascii);
                    } catch (e) { reject(new Error("CORS blocked image data access.")); }
                };
                img.onerror = () => reject(new Error("Failed to load image."));
            });
        }

        async function processCommand(rawCmd) {
            const parts = rawCmd.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);

            switch (cmd) {
                case 'help':
                    addMessage('SYSTEM', 'COMMANDS:', true);
                    addMessage(null, '  login            - Sign in with Google');
                    addMessage(null, '  logout           - Sign out');
                    addMessage(null, '  post             - Create a new log entry');
                    addMessage(null, '  profile [email]  - View user logs & bio');
                    addMessage(null, '  set-bio          - Edit your profile');
                    addMessage(null, '  chat [name/email] - Start chat');
                    addMessage(null, '  mentions         - Check tags');
                    addMessage(null, '  reqbox           - Check for new messages');
                    addMessage(null, '  status [mode]    - online/away/busy');
                    addMessage(null, '  theme [color]    - Set color');
                    addMessage(null, '  ascii [url]      - Render ASCII');
                    addMessage(null, '  clear            - Clear screen');
                    break;

                case 'clear': history.innerHTML = ''; break;
                case 'post': openPostEditor(); break;
                case 'profile': openProfileViewer(args[0]); break;
                case 'set-bio': openProfileEditor(); break;
                
                case 'whois':
                    // Alias to profile viewer for now, or keep old functionality? 
                    // Let's make it an alias for consistency
                    openProfileViewer(args[0]); 
                    break;

                case 'mentions': await showRecentMentions(); break;
                case 'emoji': 
                    addMessage('SYSTEM', 'AVAILABLE EMOJIS:', true);
                    addMessage(null, Object.keys(EMOJI_MAP).join(' '));
                    break;

                case 'status':
                    if (!ensureAuth()) return;
                    if (args[0]) await updateStatus(args[0]);
                    break;

                case 'burn':
                    if (state.mode === 'CHAT') {
                        // handled in chat loop, but here to catch errors
                        addMessage('ERROR', 'USE BURN INSIDE CHAT.', false, false, true);
                    } else {
                        addMessage('ERROR', 'ENTER A CHAT ROOM TO USE BURN.', false, false, true);
                    }
                    break;

                case 'mute': state.muted = true; addMessage('SYSTEM', 'SOUNDS MUTED.', true); break;
                case 'unmute': state.muted = false; addMessage('SYSTEM', 'SOUNDS ACTIVE.', true); break;
                
                case 'ascii':
                    if (args[0]) {
                        try {
                            const asciiArt = await fetchAscii(args[0]);
                            addMessage(null, asciiArt, false, false, false, true);
                        } catch (e) {
                            addMessage('ERROR', `FAILED: ${e.message}`, false, false, true);
                        }
                    } else {
                        fileInput.click();
                    }
                    break;

                case 'theme':
                    if (args[0] && applyTheme(args[0])) addMessage('SYSTEM', `THEME SET TO ${args[0].toUpperCase()}`, true);
                    break;

                case 'login': handleLogin(); break;
                case 'logout': signOut(auth); break;

                case 'friend':
                    if (!ensureAuth()) return;
                    if (args[0] === 'add') addFriend(args[1]);
                    else if (args[0] === 'nick') setNickname(args[1], args[2]);
                    break;

                case 'friends': if (ensureAuth()) listFriends(); break;
                case 'friends-email': if (ensureAuth()) listFriendsEmails(); break;
                case 'reqbox': if (ensureAuth()) checkReqBox(); break;
                case 'chat': if (ensureAuth()) startChat(args[0]); break;
                case 'date': addMessage('SYSTEM', new Date().toString(), true); break;
                case 'neofetch': runNeofetch(); break;
                case 'ping': if (ensureAuth()) pingUser(args[0]); break;
                case 'exit': break;

                default: addMessage('SYSTEM', `UNKNOWN COMMAND: ${cmd}`, true);
            }
        }

        // ... (Keep existing chat, friend, auth logic functions from previous code) ...
        // Re-implementing them here to ensure the full file is complete and functional

        function ensureAuth() {
            if (!currentUser || currentUser.isAnonymous) {
                addMessage('ERROR', 'ACCESS DENIED. LOGIN REQUIRED.', false, false, true);
                return false;
            }
            return true;
        }

        // ... (Rest of the previous helper functions: runNeofetch, pingUser, addFriend, setNickname, listFriends, checkReqBox, startChat, processChatInput, sendMessage, getConversationId)
        // I will include them to make the file runnable.

        async function pingUser(targetEmail) {
            addMessage('SYSTEM', `PINGING ${targetEmail}...`, true);
            const start = Date.now();
            try {
                const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'user_profiles');
                const q = query(usersRef, where("email", "==", targetEmail));
                const snapshot = await getDocs(q);
                if (!snapshot.empty) {
                    const data = snapshot.docs[0].data();
                    const ms = Date.now() - start;
                    addMessage('SYSTEM', `REPLY FROM ${targetEmail}: status=${data.status} time=${ms}ms`, true);
                } else {
                    addMessage('ERROR', `TIMEOUT: ${targetEmail} not found.`, false, false, true);
                }
            } catch (error) { addMessage('ERROR', error.message, false, false, true); }
        }

        async function addFriend(targetEmail) {
            try {
                const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'user_profiles');
                const q = query(usersRef, where("email", "==", targetEmail));
                const snapshot = await getDocs(q);
                if (snapshot.empty) { addMessage('ERROR', 'USER NOT FOUND.', false, false, true); return; }
                const targetUser = snapshot.docs[0].data();
                const myFriendsRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'friends', targetUser.uid);
                await setDoc(myFriendsRef, { email: targetUser.email, uid: targetUser.uid, displayName: targetUser.displayName }, { merge: true });
                addMessage('SYSTEM', `FRIEND ADDED.`, true);
            } catch (e) { addMessage('ERROR', e.message, false, false, true); }
        }

        async function setNickname(targetEmail, nickname) {
            try {
                const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                const q = query(friendsRef, where("email", "==", targetEmail));
                const snapshot = await getDocs(q);
                if (snapshot.empty) { addMessage('ERROR', 'FRIEND NOT FOUND.', false, false, true); return; }
                const friendDoc = snapshot.docs[0];
                await setDoc(friendDoc.ref, { nickname: nickname }, { merge: true });
                addMessage('SYSTEM', `NICKNAME SET.`, true);
            } catch (e) { addMessage('ERROR', e.message, false, false, true); }
        }

        async function listFriends() {
            try {
                const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                const snapshot = await getDocs(friendsRef);
                if (snapshot.empty) { addMessage(null, 'No friends.'); return; }
                snapshot.forEach(doc => {
                    const f = doc.data();
                    addMessage(null, `> ${f.nickname || f.displayName || f.email}`);
                });
            } catch (e) { addMessage('ERROR', e.message, false, false, true); }
        }

        async function listFriendsEmails() {
             try {
                const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                const snapshot = await getDocs(friendsRef);
                snapshot.forEach(doc => {
                    const f = doc.data();
                    addMessage(null, `> ${f.email} (${f.nickname || 'No Nick'})`);
                });
            } catch (e) { addMessage('ERROR', e.message, false, false, true); }
        }

        async function checkReqBox() {
            addMessage('SYSTEM', 'SCANNING...', true);
            try {
                const msgsRef = collection(db, 'artifacts', appId, 'public', 'data', 'messages');
                const q = query(msgsRef, where('receiverId', '==', currentUser.uid));
                const snapshot = await getDocs(q);
                const senders = new Set();
                snapshot.forEach(doc => senders.add(doc.data().senderDisplayName));
                if (senders.size === 0) addMessage(null, 'NO MESSAGES.');
                else {
                    addMessage(null, 'MESSAGES FROM:');
                    senders.forEach(s => addMessage(null, `> ${s}`));
                }
            } catch (e) { addMessage('ERROR', e.message, false, false, true); }
        }

        async function startChat(identifier) {
            try {
                let friendData = await resolveUserByNickOrEmail(identifier); // Re-use resolver
                // Also check local friends list if not found globally
                if (!friendData) {
                     const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                     let q = query(friendsRef, where("nickname", "==", identifier));
                     let s = await getDocs(q);
                     if(s.empty) {
                         q = query(friendsRef, where("email", "==", identifier));
                         s = await getDocs(q);
                     }
                     if(!s.empty) friendData = s.docs[0].data();
                }

                if (!friendData) { addMessage('ERROR', 'USER NOT FOUND.', false, false, true); return; }

                currentChatPartner = friendData;
                state.mode = 'CHAT';
                history.innerHTML = '';
                addMessage('SYSTEM', `--- CONNECTED TO ${friendData.displayName || friendData.email} ---`, true);
                updatePrompt(currentUser.email);

                const convoId = getConversationId(currentUser.uid, friendData.uid);
                const msgsRef = collection(db, 'artifacts', appId, 'public', 'data', 'messages');
                const qMsg = query(msgsRef, where('conversationId', '==', convoId)); // No orderBy for safety

                if (messagesUnsubscribe) messagesUnsubscribe();
                
                // Manual sort in listener
                let allMsgs = [];
                messagesUnsubscribe = onSnapshot(qMsg, (snapshot) => {
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added') allMsgs.push(change.doc.data());
                    });
                    allMsgs.sort((a,b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0));
                    
                    history.innerHTML = '';
                    addMessage('SYSTEM', `--- CONNECTED TO ${friendData.displayName || friendData.email} ---`, true);
                    allMsgs.forEach(msg => {
                        const sender = msg.senderId === currentUser.uid ? 'ME' : (friendData.nickname || friendData.displayName);
                        addMessage(sender, msg.text, false, true, false, msg.isAscii, null, msg.burn);
                    });
                });

            } catch (e) { addMessage('ERROR', e.message, false, false, true); }
        }

        async function processChatInput(text) {
            if (text.toLowerCase() === 'exit') {
                if (messagesUnsubscribe) messagesUnsubscribe();
                state.mode = 'COMMAND';
                currentChatPartner = null;
                history.innerHTML = '';
                addMessage('SYSTEM', 'DISCONNECTED.', true);
                updatePrompt(currentUser.email.split('@')[0]);
                return;
            }
            if (text.toLowerCase() === 'ascii') { fileInput.click(); return; }
            
            let isBurn = false;
            let content = text;
            if (content.toLowerCase().startsWith('burn ')) { isBurn = true; content = content.substring(5); }
            content = parseEmojis(content);
            
            await sendMessage(content, false, isBurn);
        }

        async function sendMessage(text, isAscii, isBurn) {
            const msgsRef = collection(db, 'artifacts', appId, 'public', 'data', 'messages');
            const convoId = getConversationId(currentUser.uid, currentChatPartner.uid);
            
            try {
                const docRef = await addDoc(msgsRef, {
                    conversationId: convoId,
                    text: text,
                    senderId: currentUser.uid,
                    senderDisplayName: currentUser.displayName,
                    receiverId: currentChatPartner.uid,
                    burn: isBurn,
                    isAscii: isAscii,
                    timestamp: serverTimestamp()
                });
                if(isBurn) setTimeout(() => deleteDoc(docRef), 10000);
            } catch(e) { addMessage('ERROR', 'SEND FAILED.', false, false, true); }
        }

        function getConversationId(uid1, uid2) { return [uid1, uid2].sort().join('_'); }

        function runNeofetch() {
             addMessage(null, `
             USER: ${currentUser ? currentUser.email : 'Guest'}
             OS:   Web Terminal
             TIME: ${new Date().toLocaleTimeString()}
             `, false, false, false, true);
        }

    </script>
</body>
</html>