<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T-CHAT_LINK_V2.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Default Theme: Green Phosphor */
            --terminal-main: #33ff00;
            --terminal-glow: #33ff00;
            --terminal-bg: #0a0a0a;
            --bezel-color: #222;
            
            /* Secondary colors */
            --system-color: #ffaa00; 
            --chat-color: #00ccff;
            --error-color: #ff3333;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--terminal-bg);
            height: 100vh;
            width: 100vw;
            font-family: 'VT323', monospace;
            overflow: hidden;
        }

        .crt-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .bezel-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 25px solid var(--bezel-color);
            border-radius: 20px;
            box-shadow: inset 0 0 20px #000;
            pointer-events: none;
            z-index: 20;
        }

        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
            z-index: 10;
            animation: flicker 0.15s infinite;
        }

        .crt-overlay::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.4) 100%);
            z-index: 10;
        }

        .terminal-content {
            height: 100%;
            width: 100%;
            padding: 40px;
            box-sizing: border-box;
            color: var(--terminal-main);
            text-shadow: 0 0 4px var(--terminal-glow);
            font-size: 1.5rem;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--terminal-main) transparent;
        }

        .terminal-content::-webkit-scrollbar { width: 10px; }
        .terminal-content::-webkit-scrollbar-track { background: #000; }
        .terminal-content::-webkit-scrollbar-thumb { background-color: var(--terminal-main); border: 2px solid #000; }

        #chat-history {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: 20px;
        }

        .message-line {
            margin-bottom: 0.5rem;
            word-wrap: break-word;
            line-height: 1.4;
            opacity: 0;
            animation: fadeIn 0.1s forwards;
            max-width: 90%;
            white-space: pre-wrap; 
            transition: opacity 0.5s ease-out; /* For burn effect fade out */
        }

        .ascii-art {
            white-space: pre;
            font-size: 0.8rem;
            line-height: 1rem;
            overflow-x: auto;
            color: var(--terminal-main);
            margin: 10px 0;
            display: block;
        }

        .system-msg { color: var(--system-color); text-shadow: 0 0 4px var(--system-color); }
        .chat-msg { color: var(--chat-color); text-shadow: 0 0 4px var(--chat-color); }
        .error-msg { color: var(--error-color); text-shadow: 0 0 4px var(--error-color); }
        .user-prefix { font-weight: bold; margin-right: 0.5rem; }

        /* Status Indicators */
        .status-dot { display: inline-block; margin-right: 8px; font-size: 1.2rem; }
        .status-online { color: var(--terminal-main); text-shadow: 0 0 5px var(--terminal-main); }
        .status-away { color: var(--system-color); text-shadow: 0 0 5px var(--system-color); }
        .status-busy { color: var(--error-color); text-shadow: 0 0 5px var(--error-color); }

        /* Burn Timer */
        .burn-timer { color: var(--error-color); margin-left: 10px; font-size: 0.8em; font-weight: bold; }

        .input-line {
            display: flex;
            align-items: center;
            border-top: 1px dashed rgba(51, 255, 0, 0.3);
            padding-top: 15px;
            padding-bottom: 5px;
            background-color: rgba(0,0,0,0.5);
            position: relative;
        }

        .prompt { margin-right: 15px; font-weight: bold; }

        .cmd-wrapper {
            position: relative;
            flex-grow: 1;
            display: flex;
            align-items: center;
            height: 1.5rem;
        }

        #command-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            z-index: 10;
            cursor: default;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            border: none;
            outline: none;
            background: transparent;
            color: transparent;
        }

        #cmd-display {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: var(--terminal-main);
            text-shadow: 0 0 4px var(--terminal-glow);
            white-space: pre;
            pointer-events: none;
            display: flex;
            width: 100%;
            overflow: hidden;
        }

        #cmd-cursor {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
            animation: blink 1s step-end infinite;
            min-width: 1ch;
            display: inline-block;
            text-align: center;
        }

        .input-line:not(:focus-within) #cmd-cursor {
            background-color: transparent;
            color: var(--terminal-main);
            border: 1px solid var(--terminal-main);
            animation: none;
        }

        /* --- Autocomplete Drop-Up Menu --- */
        #autocomplete-menu {
            position: absolute;
            bottom: 120%; /* Pushes it above the input line */
            left: 0;
            min-width: 200px;
            max-height: 250px;
            background-color: var(--terminal-bg);
            border: 1px solid var(--terminal-main);
            box-shadow: 0 0 10px rgba(0,0,0,0.8);
            display: none; /* Hidden by default */
            flex-direction: column;
            overflow-y: auto;
            z-index: 100;
        }
        
        /* Custom scrollbar for menu */
        #autocomplete-menu::-webkit-scrollbar { width: 5px; }
        #autocomplete-menu::-webkit-scrollbar-track { background: #000; }
        #autocomplete-menu::-webkit-scrollbar-thumb { background-color: var(--terminal-main); }

        .suggestion-item {
            padding: 5px 10px;
            color: var(--terminal-main);
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.3rem;
            border-bottom: 1px dotted rgba(51, 255, 0, 0.2);
        }

        .suggestion-item.selected, .suggestion-item:hover {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
        }
        /* -------------------------------- */

        @keyframes flicker {
            0% { opacity: 0.97; } 50% { opacity: 0.99; } 100% { opacity: 0.94; }
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        @keyframes fadeIn { to { opacity: 1; } }

        .power-led {
            width: 10px; height: 10px; background-color: #ff0000; border-radius: 50%;
            position: absolute; bottom: 30px; right: 30px; box-shadow: 0 0 8px #ff0000;
            z-index: 25; pointer-events: none;
        }

        .brand-logo {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            color: #333; font-size: 1rem; font-family: sans-serif; letter-spacing: 4px;
            font-weight: bold; z-index: 25; pointer-events: none;
            text-shadow: 0 1px 1px rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div class="crt-container">
        <div class="crt-overlay"></div>
        <div class="bezel-overlay"></div>
        <div class="power-led"></div>
        <div class="brand-logo">SONY TRINITRON</div>

        <div class="terminal-content" id="terminal-container">
            <div id="chat-history">
                <div class="message-line system-msg">BOOT_SEQUENCE_INIT...</div>
                <div class="message-line system-msg">LOADING T-CHAT MODULES...</div>
                <div class="message-line">Welcome to T-CHAT.</div>
                <div class="message-line">Status: CONNECTING...</div>
            </div>

            <div class="input-line">
                <span class="prompt" id="prompt-span">...</span>
                <div class="cmd-wrapper">
                    <!-- Autocomplete Menu -->
                    <div id="autocomplete-menu"></div>
                    
                    <input type="text" id="command-input" autocomplete="off" autofocus>
                    <div id="cmd-display">
                        <span id="cmd-before"></span><span id="cmd-cursor">&nbsp;</span><span id="cmd-after"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signInAnonymously, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, where, onSnapshot, orderBy, serverTimestamp, setDoc, doc, getDocs, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuration ---
        const appId = 'tchat-terminal'; 
        
        const firebaseConfig = {
            apiKey: "AIzaSyCc4hgOZCeHnBgcwHk7mWMaQEbjodVLuc4",
            authDomain: "tchat-b75ee.firebaseapp.com",
            projectId: "tchat-b75ee",
            storageBucket: "tchat-b75ee.firebasestorage.app",
            messagingSenderId: "602448689642",
            appId: "1:602448689642:web:435a9f48ea2e80debeda93",
            measurementId: "G-T7P87XTZ15"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        setPersistence(auth, browserLocalPersistence).catch(console.error);

        // --- State ---
        let currentUser = null;
        let currentChatPartner = null; 
        let messagesUnsubscribe = null;
        const state = {
            mode: 'COMMAND', 
            muted: false
        };
        
        // --- Command History ---
        const cmdHistory = [];
        let historyIndex = -1;

        // --- Autocomplete Data ---
        const commandsList = [
            'help', 'login', 'friend', 'friends', 'chat', 
            'burn', 'theme', 'ascii', 'mute', 'unmute', 
            'clear', 'status', 'date', 'exit'
        ];

        const subCommands = {
            'theme': ['green', 'amber', 'blue', 'white', 'matrix'],
            'status': ['online', 'away', 'busy'],
            'friend': ['add']
        };

        let autocompleteOptions = [];
        let autocompleteIndex = -1;

        // --- Sound System ---
        const SoundSys = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone: function(freq, type, duration, vol=0.1) {
                if (state.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            click: function() { this.playTone(800, 'square', 0.05, 0.05); },
            blip: function() { this.playTone(1200, 'sine', 0.15, 0.1); }
        };

        // --- Theme System ---
        const Themes = {
            green: { main: '#33ff00', system: '#ffaa00', chat: '#00ccff', error: '#ff3333' },
            amber: { main: '#ffb000', system: '#ffcc00', chat: '#ffb000', error: '#ff5500' },
            blue:  { main: '#0088ff', system: '#00aaff', chat: '#00ffff', error: '#ff3333' },
            white: { main: '#e0e0e0', system: '#ffffff', chat: '#cccccc', error: '#ff3333' },
            matrix: { main: '#00ff41', system: '#008f11', chat: '#003b00', error: '#ff3333' }
        };

        function applyTheme(themeName) {
            const theme = Themes[themeName];
            if (!theme) return false;
            const r = document.documentElement;
            r.style.setProperty('--terminal-main', theme.main);
            r.style.setProperty('--terminal-glow', theme.main);
            r.style.setProperty('--system-color', theme.system);
            r.style.setProperty('--chat-color', theme.chat);
            r.style.setProperty('--error-color', theme.error);
            return true;
        }

        // --- UI References ---
        const input = document.getElementById('command-input');
        const history = document.getElementById('chat-history');
        const container = document.getElementById('terminal-container');
        const promptSpan = document.getElementById('prompt-span');
        const cmdBefore = document.getElementById('cmd-before');
        const cmdCursor = document.getElementById('cmd-cursor');
        const cmdAfter = document.getElementById('cmd-after');
        const autocompleteMenu = document.getElementById('autocomplete-menu');

        function updateInputDisplay() {
            const val = input.value;
            const selStart = input.selectionStart || 0;
            const left = val.substring(0, selStart);
            const char = val.substring(selStart, selStart + 1) || '\u00A0';
            const right = val.substring(selStart + 1);

            cmdBefore.textContent = left;
            cmdCursor.textContent = char;
            cmdAfter.textContent = right;
        }

        ['input', 'click', 'focus', 'blur'].forEach(evt => {
            input.addEventListener(evt, () => requestAnimationFrame(updateInputDisplay));
        });

        // --- Autocomplete Logic ---
        function showAutocompleteMenu(options) {
            autocompleteMenu.innerHTML = '';
            autocompleteOptions = options;
            autocompleteIndex = -1;

            if (options.length === 0) {
                autocompleteMenu.style.display = 'none';
                return;
            }

            options.forEach((opt, index) => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.textContent = opt;
                div.onclick = () => confirmSelection(opt);
                autocompleteMenu.appendChild(div);
            });

            autocompleteMenu.style.display = 'flex';
        }

        function hideAutocomplete() {
            autocompleteMenu.style.display = 'none';
            autocompleteOptions = [];
            autocompleteIndex = -1;
        }

        function highlightOption(index) {
            const items = autocompleteMenu.children;
            for (let i = 0; i < items.length; i++) {
                items[i].classList.remove('selected');
            }
            if (index >= 0 && index < items.length) {
                items[index].classList.add('selected');
                items[index].scrollIntoView({ block: 'nearest' });
            }
        }

        function confirmSelection(selectedValue) {
            const parts = input.value.split(' ');
            
            // If we are suggesting arguments (parts.length > 1), keep command
            if (parts.length > 1) {
                // Command + Argument
                input.value = parts[0] + ' ' + selectedValue + ' ';
            } else {
                // Just Command
                input.value = selectedValue + ' ';
            }
            
            hideAutocomplete();
            updateInputDisplay();
            input.focus();
        }

        function handleTabCompletion(e) {
            e.preventDefault();

            // If menu is open, cycle through it
            if (autocompleteMenu.style.display === 'flex') {
                autocompleteIndex = (autocompleteIndex + 1) % autocompleteOptions.length;
                highlightOption(autocompleteIndex);
                return;
            }

            // Logic to find matches
            const val = input.value;
            const parts = val.trimStart().split(/\s+/); // Split by space
            const currentWord = parts[parts.length - 1]; // Word currently being typed?
            
            let matches = [];

            // Case 1: Typing command (1st word)
            if (parts.length === 1 && !val.endsWith(' ')) {
                matches = commandsList.filter(cmd => cmd.startsWith(currentWord));
            } 
            // Case 2: Typing argument (2nd word or space after 1st)
            else if (parts.length >= 1) {
                const cmd = parts[0];
                const arg = (parts.length > 1) ? parts[1] : ""; 
                
                if (subCommands[cmd]) {
                    // Check if we already typed space implies we are looking for args
                    if (val.endsWith(' ') || parts.length > 1) {
                        matches = subCommands[cmd].filter(sub => sub.startsWith(arg));
                    }
                }
            }

            if (matches.length === 1) {
                // Exact match, just fill it
                confirmSelection(matches[0]);
            } else if (matches.length > 1) {
                // Multiple matches, show menu
                showAutocompleteMenu(matches);
            }
        }

        // --- Auth & Presence ---
        const initGuestAuth = async () => {
            try { await signInAnonymously(auth); } 
            catch (e) { console.warn("Guest login failed:", e.code); }
        };

        const updateStatus = async (status) => {
            if (!currentUser || currentUser.isAnonymous) return;
            try {
                const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', currentUser.uid);
                await setDoc(userRef, {
                    status: status,
                    lastSeen: serverTimestamp()
                }, { merge: true });
                return true;
            } catch(e) { console.error(e); return false; }
        };

        onAuthStateChanged(auth, async (user) => {
            currentUser = user;
            if (user) {
                if (user.isAnonymous) {
                     updatePrompt('guest');
                     addMessage('SYSTEM', 'GUEST MODE ACTIVE.', true);
                } else {
                    updatePrompt(user.email.split('@')[0]);
                    addMessage('SYSTEM', `AUTHENTICATED AS ${user.email}`, true);
                    // Initial Status Set
                    await updateStatus('online');
                    
                    // Profile Init
                    try {
                        const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', user.uid);
                        await setDoc(userRef, {
                            email: user.email,
                            displayName: user.displayName || user.email.split('@')[0],
                            uid: user.uid,
                            status: 'online',
                            lastSeen: serverTimestamp()
                        }, { merge: true });
                    } catch (e) {}
                }
            } else {
                updatePrompt('offline');
                initGuestAuth();
            }
        });

        const handleLogin = async () => {
            try {
                addMessage('SYSTEM', 'INITIATING GOOGLE AUTH HANDSHAKE...', true);
                const provider = new GoogleAuthProvider();
                await signInWithPopup(auth, provider);
            } catch (error) {
                if (error.code === 'auth/unauthorized-domain') {
                    addMessage('ERROR', 'DOMAIN NOT AUTHORIZED. Check Firebase Console.', false, false, true);
                } else {
                    addMessage('ERROR', `LOGIN FAILED: ${error.message}`, false, false, true);
                }
            }
        };

        function updatePrompt(username) {
            if (state.mode === 'CHAT') {
                promptSpan.textContent = `[CHAT:${currentChatPartner.email}] >`;
            } else {
                promptSpan.textContent = `${username}@TChat:~$`;
            }
        }

        // --- Effects ---
        function scrambleText(element, finalValidText) {
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()";
            let iterations = 0;
            const originalText = finalValidText;
            
            const interval = setInterval(() => {
                element.innerText = originalText.split('').map((char, index) => {
                    if (char === ' ' || char === '\n') return char; 
                    if (index < iterations) return originalText[index];
                    return chars[Math.floor(Math.random() * chars.length)];
                }).join('');
                
                if (iterations >= originalText.length) {
                    clearInterval(interval);
                    element.innerText = originalText;
                }
                iterations += 1 + Math.floor(originalText.length / 30); 
            }, 50);
        }

        // Map Firestore msg ID to DOM element for deletion
        const msgMap = new Map();

        function addMessage(sender, text, isSystem = false, isChat = false, isError = false, isAscii = false, msgId = null, isBurn = false) {
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('message-line');
            if (isSystem) msgDiv.classList.add('system-msg');
            if (isChat) msgDiv.classList.add('chat-msg');
            if (isError) msgDiv.classList.add('error-msg');
            if (isAscii) msgDiv.classList.add('ascii-art');

            if (msgId) {
                msgDiv.setAttribute('data-msg-id', msgId);
                msgMap.set(msgId, msgDiv);
            }

            if (!state.muted && (isSystem || (isChat && sender !== 'ME'))) {
                setTimeout(() => SoundSys.blip(), 50);
            }

            const contentSpan = document.createElement('span');

            if (sender) {
                let prefixColor = 'var(--terminal-main)';
                if (isChat) prefixColor = 'var(--chat-color)';
                if (isSystem) prefixColor = 'var(--system-color)';
                if (isError) prefixColor = 'var(--error-color)';
                
                const prefixSpan = document.createElement('span');
                prefixSpan.className = 'user-prefix';
                prefixSpan.style.color = prefixColor;
                prefixSpan.textContent = `[${sender}]: `;
                msgDiv.appendChild(prefixSpan);
            }

            if (isAscii) {
                contentSpan.textContent = text;
            } else {
                contentSpan.textContent = text; 
            }

            msgDiv.appendChild(contentSpan);

            // Burn Logic Visuals
            if (isBurn) {
                const burnSpan = document.createElement('span');
                burnSpan.className = 'burn-timer';
                burnSpan.textContent = ' [üî• 10s]';
                msgDiv.appendChild(burnSpan);

                // Local countdown visual (actual deletion handled by DB listener or sender)
                let left = 10;
                const timer = setInterval(() => {
                    left--;
                    if(left >= 0) burnSpan.textContent = ` [üî• ${left}s]`;
                    else {
                        clearInterval(timer);
                    }
                }, 1000);
            }

            history.appendChild(msgDiv);
            scrollToBottom();

            if ((isChat && sender !== 'ME') || isSystem) {
                if (!isAscii) scrambleText(contentSpan, text);
            }

            return msgDiv;
        }

        function scrollToBottom() {
            container.scrollTop = container.scrollHeight;
        }

        // --- Command Processing ---
        input.addEventListener('keydown', function(event) {
            SoundSys.init();
            
            // --- Autocomplete Handling ---
            if (event.key === 'Tab') {
                handleTabCompletion(event);
                return; // Stop other processing
            }

            // If menu is open, handle navigation keys specially
            if (autocompleteMenu.style.display === 'flex') {
                if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    autocompleteIndex = (autocompleteIndex - 1 + autocompleteOptions.length) % autocompleteOptions.length;
                    highlightOption(autocompleteIndex);
                    return;
                }
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    autocompleteIndex = (autocompleteIndex + 1) % autocompleteOptions.length;
                    highlightOption(autocompleteIndex);
                    return;
                }
                if (event.key === 'Enter') {
                    if (autocompleteIndex >= 0) {
                        event.preventDefault();
                        confirmSelection(autocompleteOptions[autocompleteIndex]);
                        return;
                    }
                    // If no selection, allow Enter to submit command normally, but hide menu
                    hideAutocomplete();
                }
                if (event.key === 'Escape') {
                    hideAutocomplete();
                    return;
                }
            } else {
                // --- Normal History Navigation (only if menu closed) ---
                if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    if (cmdHistory.length > 0) {
                        if (historyIndex < cmdHistory.length - 1) {
                            historyIndex++;
                            input.value = cmdHistory[cmdHistory.length - 1 - historyIndex];
                            updateInputDisplay();
                        }
                    }
                    return;
                }
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        input.value = cmdHistory[cmdHistory.length - 1 - historyIndex];
                    } else if (historyIndex === 0) {
                        historyIndex = -1;
                        input.value = '';
                    }
                    updateInputDisplay();
                    return;
                }
            }

            // --- Hiding menu on typing (reset) ---
            // If user types normal keys, we might want to hide menu or refine search?
            // For simple retro style, let's hide menu if they type non-nav keys so they can re-tab
            if (event.key.length === 1 || event.key === 'Backspace') {
                 if (event.key !== 'Tab') hideAutocomplete();
            }

            if (!['Enter', 'Shift', 'Control', 'Alt', 'ArrowUp', 'ArrowDown', 'Tab'].includes(event.key)) {
                SoundSys.click();
            }

            if (event.key === 'Enter') {
                const text = input.value; 
                const trimmed = text.trim();
                
                if (trimmed !== "") {
                    cmdHistory.push(trimmed);
                    historyIndex = -1;

                    if (state.mode === 'COMMAND') {
                        addMessage('ME', trimmed);
                        processCommand(trimmed);
                    } else {
                        processChatInput(trimmed);
                    }
                    input.value = '';
                    updateInputDisplay();
                }
            }
            requestAnimationFrame(updateInputDisplay);
        });

        document.addEventListener('click', (e) => { 
            input.focus(); 
            SoundSys.init();
            // Close autocomplete if clicking outside
            if (e.target !== autocompleteMenu && e.target.parentElement !== autocompleteMenu) {
                hideAutocomplete();
            }
        });
        window.onload = () => input.focus();

        async function processCommand(rawCmd) {
            const parts = rawCmd.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);

            switch (cmd) {
                case 'help':
                    addMessage('SYSTEM', 'COMMANDS:', true);
                    addMessage(null, '  login            - Sign in with Google');
                    addMessage(null, '  friend add [email] - Add a friend');
                    addMessage(null, '  friends          - List friends & status');
                    addMessage(null, '  status [mode]    - online/away/busy');
                    addMessage(null, '  chat [email]     - Start chat');
                    addMessage(null, '  burn [msg]       - Send self-destruct msg');
                    addMessage(null, '  theme [color]    - Set color');
                    addMessage(null, '  ascii [url]      - Render ASCII');
                    addMessage(null, '  mute / unmute    - Toggle sounds');
                    addMessage(null, '  clear            - Clear screen');
                    break;

                case 'clear':
                    history.innerHTML = '';
                    break;

                case 'status':
                    if (!ensureAuth()) return;
                    const validStatuses = ['online', 'away', 'busy'];
                    if (args[0] && validStatuses.includes(args[0])) {
                        await updateStatus(args[0]);
                        addMessage('SYSTEM', `STATUS SET TO: ${args[0].toUpperCase()}`, true);
                    } else {
                        addMessage('SYSTEM', 'USAGE: status [online | away | busy]', true);
                    }
                    break;

                case 'burn':
                    if (state.mode === 'CHAT') {
                        addMessage('ERROR', 'ENTER A CHAT ROOM TO USE BURN.', false, false, true);
                    } else {
                        addMessage('ERROR', 'ENTER A CHAT ROOM TO USE BURN.', false, false, true);
                    }
                    break;

                case 'mute':
                    state.muted = true;
                    addMessage('SYSTEM', 'SOUNDS MUTED.', true);
                    break;

                case 'unmute':
                    state.muted = false;
                    SoundSys.init();
                    SoundSys.blip(); 
                    addMessage('SYSTEM', 'SOUNDS ACTIVE.', true);
                    break;
                
                case 'ascii':
                    if (args[0]) {
                        addMessage('SYSTEM', `FETCHING ASCII FROM ${args[0]}...`, true);
                        try {
                            const response = await fetch(args[0]);
                            if (!response.ok) throw new Error("Network error");
                            const text = await response.text();
                            addMessage(null, text, false, false, false, true);
                        } catch (e) {
                            addMessage('ERROR', `FAILED: ${e.message}`, false, false, true);
                        }
                    } else {
                        addMessage('SYSTEM', 'USAGE: ascii [url]', true);
                    }
                    break;

                case 'theme':
                    if (args[0] && applyTheme(args[0])) {
                        addMessage('SYSTEM', `THEME SET TO ${args[0].toUpperCase()}`, true);
                    } else {
                        addMessage('SYSTEM', 'USAGE: theme [green|amber|blue|white|matrix]', true);
                    }
                    break;

                case 'login':
                    if (currentUser && !currentUser.isAnonymous) {
                        addMessage('SYSTEM', 'ALREADY LOGGED IN.', true);
                    } else {
                        await handleLogin();
                    }
                    break;

                case 'friend':
                    if (!ensureAuth()) return;
                    if (args[0] === 'add' && args[1]) {
                        addFriend(args[1]);
                    } else {
                        addMessage('SYSTEM', 'USAGE: friend add [email]', true);
                    }
                    break;

                case 'friends':
                    if (!ensureAuth()) return;
                    listFriends();
                    break;

                case 'chat':
                    if (!ensureAuth()) return;
                    if (args[0]) {
                        startChat(args[0]);
                    } else {
                        addMessage('SYSTEM', 'USAGE: chat [email]', true);
                    }
                    break;

                case 'date':
                    addMessage('SYSTEM', new Date().toString(), true);
                    break;

                case 'exit':
                    // Just clear the prompt or something?
                    // Usually handled in processChatInput
                    break;

                default:
                    addMessage('SYSTEM', `UNKNOWN COMMAND: ${cmd}`, true);
            }
        }

        function ensureAuth() {
            if (!currentUser || currentUser.isAnonymous) {
                addMessage('ERROR', 'ACCESS DENIED. LOGIN REQUIRED.', false, false, true);
                return false;
            }
            return true;
        }

        // --- Feature Implementation ---

        async function addFriend(targetEmail) {
            addMessage('SYSTEM', `SEARCHING...`, true);
            try {
                const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'user_profiles');
                const q = query(usersRef, where("email", "==", targetEmail));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    addMessage('ERROR', 'USER NOT FOUND.', false, false, true);
                    return;
                }
                const targetUser = snapshot.docs[0].data();
                const myFriendsRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'friends', targetUser.uid);
                await setDoc(myFriendsRef, {
                    email: targetUser.email,
                    uid: targetUser.uid,
                    displayName: targetUser.displayName,
                    addedAt: serverTimestamp()
                });
                addMessage('SYSTEM', `FRIEND ADDED.`, true);
            } catch (error) {
                addMessage('ERROR', 'DB ERROR: ' + error.message, false, false, true);
            }
        }

        async function listFriends() {
            addMessage('SYSTEM', 'FETCHING FRIEND LIST & STATUS...', true);
            try {
                const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                const snapshot = await getDocs(friendsRef);
                if (snapshot.empty) {
                    addMessage(null, 'No friends found.');
                    return;
                }
                
                // Fetch status for each friend
                const promises = snapshot.docs.map(async (docSnap) => {
                    const friend = docSnap.data();
                    const profileRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', friend.uid);
                    const profileSnap = await getDoc(profileRef);
                    let status = 'offline';
                    if (profileSnap.exists()) {
                        status = profileSnap.data().status || 'offline';
                    }
                    return { ...friend, status };
                });

                const friendsWithStatus = await Promise.all(promises);

                friendsWithStatus.forEach(f => {
                    let dotClass = 'status-online'; // default
                    if (f.status === 'away') dotClass = 'status-away';
                    if (f.status === 'busy') dotClass = 'status-busy';
                    
                    const div = document.createElement('div');
                    div.className = 'message-line';
                    div.innerHTML = `<span class="status-dot ${dotClass}">‚óè</span> ${f.email}`;
                    history.appendChild(div);
                });
                scrollToBottom();

            } catch (error) {
                addMessage('ERROR', error.message, false, false, true);
            }
        }

        async function startChat(friendEmail) {
            try {
                const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                const q = query(friendsRef, where("email", "==", friendEmail));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    addMessage('ERROR', 'FRIEND NOT FOUND. ADD FIRST.', false, false, true);
                    return;
                }

                const friendData = snapshot.docs[0].data();
                currentChatPartner = friendData;
                
                state.mode = 'CHAT';
                history.innerHTML = ''; 
                addMessage('SYSTEM', `--- CONNECTION ESTABLISHED: ${friendData.email} ---`, true);
                addMessage('SYSTEM', `CMDS: 'burn [msg]', 'exit'`, true);
                updatePrompt(currentUser.email);

                const convoId = getConversationId(currentUser.uid, friendData.uid);
                const msgsRef = collection(db, 'artifacts', appId, 'public', 'data', 'messages');
                
                const qMsg = query(msgsRef, where('conversationId', '==', convoId), orderBy('timestamp', 'asc'));

                if (messagesUnsubscribe) messagesUnsubscribe();

                messagesUnsubscribe = onSnapshot(qMsg, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        // HANDLE ADDED
                        if (change.type === "added") {
                            const msg = change.doc.data();
                            const senderName = msg.senderId === currentUser.uid ? 'ME' : friendData.email.split('@')[0];
                            addMessage(senderName, msg.text, false, true, false, false, change.doc.id, msg.burn);
                        }
                        // HANDLE REMOVED (Burned messages)
                        if (change.type === "removed") {
                            const msgId = change.doc.id;
                            const el = msgMap.get(msgId);
                            if (el) {
                                el.style.opacity = '0';
                                setTimeout(() => el.remove(), 500); // Wait for fade out
                                msgMap.delete(msgId);
                            }
                        }
                    });
                }, (error) => {
                     if(error.message.includes("index")) {
                         addMessage('ERROR', 'INDEX REQUIRED. Check console.', false, false, true);
                         console.error(error);
                     }
                });
            } catch (error) {
                addMessage('ERROR', 'CHAT ERROR: ' + error.message, false, false, true);
            }
        }

        async function processChatInput(text) {
            const lowText = text.toLowerCase();
            
            if (lowText === 'exit') {
                if (messagesUnsubscribe) messagesUnsubscribe();
                messagesUnsubscribe = null;
                state.mode = 'COMMAND';
                currentChatPartner = null;
                history.innerHTML = '';
                addMessage('SYSTEM', 'DISCONNECTED.', true);
                updatePrompt(currentUser.email.split('@')[0]);
                return;
            }

            // Burn Command Check
            let isBurn = false;
            let finalBody = text;
            
            if (lowText.startsWith('burn ')) {
                isBurn = true;
                finalBody = text.substring(5); // Remove 'burn '
            }

            const convoId = getConversationId(currentUser.uid, currentChatPartner.uid);
            const msgsRef = collection(db, 'artifacts', appId, 'public', 'data', 'messages');

            try {
                const docRef = await addDoc(msgsRef, {
                    conversationId: convoId,
                    text: finalBody,
                    senderId: currentUser.uid,
                    receiverId: currentChatPartner.uid,
                    burn: isBurn,
                    timestamp: serverTimestamp()
                });

                // If it's a burn message, schedule deletion from the sender side
                if (isBurn) {
                    setTimeout(async () => {
                        try {
                            await deleteDoc(docRef);
                            // Visual removal happens via onSnapshot 'removed' event
                        } catch(e) { console.error("Burn failed", e); }
                    }, 10000);
                }

            } catch (e) {
                addMessage('ERROR', 'SEND FAILED: ' + e.message, false, false, true);
            }
        }

        function getConversationId(uid1, uid2) {
            return [uid1, uid2].sort().join('_');
        }

    </script>
</body>
</html>