<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T-CHAT_LINK_V2.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Default Theme: Green Phosphor */
            --terminal-main: #33ff00;
            --terminal-glow: #33ff00;
            --terminal-bg: #0a0a0a;
            --bezel-color: #222;
            
            /* Secondary colors */
            --system-color: #ffaa00; 
            --chat-color: #00ccff;
            --error-color: #ff3333;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--terminal-bg);
            height: 100vh;
            width: 100vw;
            font-family: 'VT323', monospace;
            overflow: hidden;
        }

        .crt-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .bezel-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 25px solid var(--bezel-color);
            border-radius: 20px;
            box-shadow: inset 0 0 20px #000;
            pointer-events: none;
            z-index: 20;
        }

        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
            z-index: 10;
            animation: flicker 0.15s infinite;
        }

        .crt-overlay::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.4) 100%);
            z-index: 10;
        }

        .terminal-content {
            height: 100%;
            width: 100%;
            padding: 40px;
            box-sizing: border-box;
            color: var(--terminal-main);
            text-shadow: 0 0 4px var(--terminal-glow);
            font-size: 1.5rem;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--terminal-main) transparent;
        }

        .terminal-content::-webkit-scrollbar { width: 10px; }
        .terminal-content::-webkit-scrollbar-track { background: #000; }
        .terminal-content::-webkit-scrollbar-thumb { background-color: var(--terminal-main); border: 2px solid #000; }

        #chat-history {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: 20px;
        }

        .message-line {
            margin-bottom: 0.5rem;
            word-wrap: break-word;
            line-height: 1.4;
            opacity: 0;
            animation: fadeIn 0.1s forwards;
            max-width: 90%;
            white-space: pre-wrap; 
            transition: opacity 0.5s ease-out; /* For burn effect fade out */
        }

        .ascii-art {
            white-space: pre;
            font-size: 0.8rem;
            line-height: 1rem;
            overflow-x: auto;
            color: var(--terminal-main);
            margin: 10px 0;
            display: block;
        }

        .system-msg { color: var(--system-color); text-shadow: 0 0 4px var(--system-color); }
        .chat-msg { color: var(--chat-color); text-shadow: 0 0 4px var(--chat-color); }
        .error-msg { color: var(--error-color); text-shadow: 0 0 4px var(--error-color); }
        .user-prefix { font-weight: bold; margin-right: 0.5rem; }

        /* Status Indicators */
        .status-dot { display: inline-block; margin-right: 8px; font-size: 1.2rem; }
        .status-online { color: var(--terminal-main); text-shadow: 0 0 5px var(--terminal-main); }
        .status-away { color: var(--system-color); text-shadow: 0 0 5px var(--system-color); }
        .status-busy { color: var(--error-color); text-shadow: 0 0 5px var(--error-color); }

        /* Burn Timer */
        .burn-timer { color: var(--error-color); margin-left: 10px; font-size: 0.8em; font-weight: bold; }

        .input-line {
            display: flex;
            align-items: center;
            border-top: 1px dashed rgba(51, 255, 0, 0.3);
            padding-top: 15px;
            padding-bottom: 5px;
            background-color: rgba(0,0,0,0.5);
            position: relative;
        }

        .prompt { margin-right: 15px; font-weight: bold; }

        .cmd-wrapper {
            position: relative;
            flex-grow: 1;
            display: flex;
            align-items: center;
            height: 1.5rem;
        }

        #command-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            z-index: 10;
            cursor: default;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            border: none;
            outline: none;
            background: transparent;
            color: transparent;
        }

        #cmd-display {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: var(--terminal-main);
            text-shadow: 0 0 4px var(--terminal-glow);
            white-space: pre;
            pointer-events: none;
            display: flex;
            width: 100%;
            overflow: hidden;
        }

        #cmd-cursor {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
            animation: blink 1s step-end infinite;
            min-width: 1ch;
            display: inline-block;
            text-align: center;
        }

        .input-line:not(:focus-within) #cmd-cursor {
            background-color: transparent;
            color: var(--terminal-main);
            border: 1px solid var(--terminal-main);
            animation: none;
        }

        /* --- Autocomplete Drop-Up Menu --- */
        #autocomplete-menu {
            position: absolute;
            bottom: 120%; /* Pushes it above the input line */
            left: 0;
            min-width: 200px;
            max-height: 250px;
            background-color: var(--terminal-bg);
            border: 1px solid var(--terminal-main);
            box-shadow: 0 0 10px rgba(0,0,0,0.8);
            display: none; /* Hidden by default */
            flex-direction: column;
            overflow-y: auto;
            z-index: 100;
        }
        
        /* Custom scrollbar for menu */
        #autocomplete-menu::-webkit-scrollbar { width: 5px; }
        #autocomplete-menu::-webkit-scrollbar-track { background: #000; }
        #autocomplete-menu::-webkit-scrollbar-thumb { background-color: var(--terminal-main); }

        .suggestion-item {
            padding: 5px 10px;
            color: var(--terminal-main);
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.3rem;
            border-bottom: 1px dotted rgba(51, 255, 0, 0.2);
        }

        .suggestion-item.selected, .suggestion-item:hover {
            background-color: var(--terminal-main);
            color: var(--terminal-bg);
        }
        /* -------------------------------- */

        @keyframes flicker {
            0% { opacity: 0.97; } 50% { opacity: 0.99; } 100% { opacity: 0.94; }
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        @keyframes fadeIn { to { opacity: 1; } }

        .power-led {
            width: 10px; height: 10px; background-color: #ff0000; border-radius: 50%;
            position: absolute; bottom: 30px; right: 30px; box-shadow: 0 0 8px #ff0000;
            z-index: 25; pointer-events: none;
        }

        .brand-logo {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            color: #333; font-size: 1rem; font-family: sans-serif; letter-spacing: 4px;
            font-weight: bold; z-index: 25; pointer-events: none;
            text-shadow: 0 1px 1px rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div class="crt-container">
        <div class="crt-overlay"></div>
        <div class="bezel-overlay"></div>
        <div class="power-led"></div>
        <div class="brand-logo">SONY TRINITRON</div>

        <div class="terminal-content" id="terminal-container">
            <div id="chat-history">
                <div class="message-line system-msg">BOOT_SEQUENCE_INIT...</div>
                <div class="message-line system-msg">LOADING T-CHAT MODULES...</div>
                <div class="message-line">Welcome to T-CHAT.</div>
                <div class="message-line">Status: CONNECTING...</div>
            </div>

            <div class="input-line">
                <span class="prompt" id="prompt-span">...</span>
                <div class="cmd-wrapper">
                    <!-- Autocomplete Menu -->
                    <div id="autocomplete-menu"></div>
                    
                    <input type="text" id="command-input" autocomplete="off" autofocus>
                    <div id="cmd-display">
                        <span id="cmd-before"></span><span id="cmd-cursor">&nbsp;</span><span id="cmd-after"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signInAnonymously, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, where, onSnapshot, orderBy, serverTimestamp, setDoc, doc, getDocs, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuration ---
        const appId = 'tchat-terminal'; 
        
        const firebaseConfig = {
            apiKey: "AIzaSyCc4hgOZCeHnBgcwHk7mWMaQEbjodVLuc4",
            authDomain: "tchat-b75ee.firebaseapp.com",
            projectId: "tchat-b75ee",
            storageBucket: "tchat-b75ee.firebasestorage.app",
            messagingSenderId: "602448689642",
            appId: "1:602448689642:web:435a9f48ea2e80debeda93",
            measurementId: "G-T7P87XTZ15"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        setPersistence(auth, browserLocalPersistence).catch(console.error);

        // --- State ---
        let currentUser = null;
        let currentChatPartner = null; 
        let messagesUnsubscribe = null;
        const state = {
            mode: 'COMMAND', 
            muted: false
        };
        
        // --- Command History ---
        const cmdHistory = [];
        let historyIndex = -1;

        // --- Autocomplete Data ---
        const commandsList = [
            'help', 'login', 'friend', 'friends', 'friends-email', 'chat', 
            'burn', 'theme', 'ascii', 'mute', 'unmute', 
            'clear', 'status', 'date', 'exit', 'emoji'
        ];

        const subCommands = {
            'theme': ['green', 'amber', 'blue', 'white', 'matrix'],
            'status': ['online', 'away', 'busy'],
            'friend': ['add', 'nick']
        };

        let autocompleteOptions = [];
        let autocompleteIndex = -1;

        // --- Emoji Map ---
        const EMOJI_MAP = {
            '(acid)': 'âŠ‚(â—‰â€¿â—‰)ã¤', '(afraid)': '(ã†† _ ã††)', '(alpha)': 'Î±', '(angel)': 'â˜œ(âŒ’â–½âŒ’)â˜', '(angry)': 'â€¢`_Â´â€¢',
            '(arrowhead)': 'â¤œ(â±º Ê–Ì¯â±º)â¤', '(apple)': 'ï£¿', '(ass)': '(â€¿|â€¿)', '(butt)': '(â€¿|â€¿)', '(awkward)': 'â€¢Í¡Ë˜ã‡â€¢Í¡Ë˜',
            '(bat)': '/|\\ ^._.^ /|\\', '(bear)': 'Ê•Â·Í¡á´¥Â·Ê”ï»¿', '(koala)': 'Ê•Â·Í¡á´¥Â·Ê”ï»¿', '(bearflip)': 'Ê•ãƒâ€¢á´¥â€¢Ê”ãƒ ï¸µ â”»â”â”»',
            '(bearhug)': 'Ê•ã£â€¢á´¥â€¢Ê”ã£', '(because)': 'âˆµ', '(since)': 'âˆµ', '(beta)': 'Î²', '(bigheart)': 'â¤',
            '(bitcoin)': 'â‚¿', '(blackeye)': '0__#', '(blubby)': '( 0 _ 0 )', '(blush)': '(Ëµ Í¡Â° ÍœÊ– Í¡Â°Ëµ)',
            '(bond)': 'â”Œ( ÍÂ° ÍœÊ–Í¡Â°)=Îµ/ÌµÍ‡Ì¿Ì¿/â€™Ì¿â€™Ì¿ Ì¿', '(007)': 'â”Œ( ÍÂ° ÍœÊ–Í¡Â°)=Îµ/ÌµÍ‡Ì¿Ì¿/â€™Ì¿â€™Ì¿ Ì¿', '(boobs)': '( . Y . )', '(bored)': '(-_-)',
            '(bribe)': '( â€¢Í¡Ë˜ _â€¢Í¡Ë˜)ãƒÃ°', '(bubbles)': '( Ë˜ Â³Ë˜)ãƒÂ°ï¾ŸÂºâï½¡', '(butterfly)': 'Æ¸ÓœÆ·', '(cat)': '(= Ğ¤ã‚§Ğ¤=)',
            '(catlenny)': '( Í¡Â° á´¥ Í¡Â°)ï»¿', '(check)': 'âœ”', '(cheer)': 'â€»\\(^o^)/â€»', '(chubby)': 'â•­(Ê˜Ì†~â—à±ªâ—Ÿ~Ê˜Ì†)â•®',
            '(claro)': '(Í¡ Â° ÍœÊ– Í¡ Â°)', '(clique)': 'ãƒ½à¼¼ àºˆÙ„Íœàºˆà¼¼ â–€Ì¿Ì¿Ä¹Ì¯Ì¿Ì¿â–€Ì¿ Ì¿à¼½ÆŸÍ†Ù„ÍœÆŸÍ† à¼½ï¾‰', '(gang)': 'ãƒ½à¼¼ àºˆÙ„Íœàºˆà¼¼ â–€Ì¿Ì¿Ä¹Ì¯Ì¿Ì¿â–€Ì¿ Ì¿à¼½ÆŸÍ†Ù„ÍœÆŸÍ† à¼½ï¾‰',
            '(squad)': 'ãƒ½à¼¼ àºˆÙ„Íœàºˆà¼¼ â–€Ì¿Ì¿Ä¹Ì¯Ì¿Ì¿â–€Ì¿ Ì¿à¼½ÆŸÍ†Ù„ÍœÆŸÍ† à¼½ï¾‰', '(cloud)': 'â˜', '(club)': 'â™£', '(coffee)': 'c[_]', '(cuppa)': 'c[_]',
            '(cmd)': 'âŒ˜', '(command)': 'âŒ˜', '(cool)': '(â€¢_â€¢) ( â€¢_â€¢)>âŒâ– -â–  (âŒâ– _â– )', '(csi)': '(â€¢_â€¢) ( â€¢_â€¢)>âŒâ– -â–  (âŒâ– _â– )',
            '(copy)': 'Â©', '(c)': 'Â©', '(creep)': 'Ô…(â‰–â€¿â‰–Ô…)', '(creepcute)': 'Æª(Ú“×²)â€Æªâ€‹â€‹', '(crim3s)': '( âœœï¸µâœœ )',
            '(cross)': 'â€ ', '(cry)': '(â•¥ï¹â•¥)', '(crywave)': '( â•¥ï¹â•¥) ãƒã‚·', '(cute)': '(ï½¡â—•â€¿â€¿â—•ï½¡)', '(d1)': 'âš€',
            '(d2)': 'âš', '(d3)': 'âš‚', '(d4)': 'âšƒ', '(d5)': 'âš„', '(d6)': 'âš…', '(dab)': 'ãƒ½( â€¢_)á•—',
            '(damnyou)': '(á•— Í Â° à¨Š Í Â° )á•—', '(dance)': 'á••(âŒâ– _â– )á•— â™ªâ™¬', '(dead)': 'xâ¸‘x', '(dealwithit)': '(âŒâ– _â– )',
            '(dwi)': '(âŒâ– _â– )', '(delta)': 'Î”', '(depressed)': '(ï¸¶ï¸¹ï¸¶)', '(derp)': 'â˜‰ â€¿ âš†', '(diamond)': 'â™¦',
            '(dj)': 'd[-_-]b', '(dog)': '(â—•á´¥â—•Ê‹)', '(dollar)': '$', '(dollarbill)': '[Ì²Ì…$Ì²Ì…(Ì²Ì…Î¹Î¿Ì²Ì…Ì…)Ì²Ì…$Ì²Ì…]',
            '($)': '[Ì²Ì…$Ì²Ì…(Ì²Ì…Î¹Î¿Ì²Ì…Ì…)Ì²Ì…$Ì²Ì…]', '(dong)': '(Ì¿â–€Ì¿â€‰Ì¿Ä¹Ì¯Ì¿Ì¿â–€Ì¿ Ì¿)Ì„', '(donger)': 'ãƒ½à¼¼àºˆÙ„Íœàºˆà¼½ï¾‰', '(dontcare)': '(- Ê–Ì¯-)',
            '(idc)': '(- Ê–Ì¯-)', '(dontwant)': 'ãƒ½(ï½€Ğ”Â´)ï¾‰', '(do not want)': 'ãƒ½(ï½€Ğ”Â´)ï¾‰', '(dope)': '<(^_^)>',
            '(<<)': 'Â«', '(>>))': 'Â»', '(doubleflat)': 'ğ„«', '(doublesharp)': 'ğ„ª', '(doubletableflip)': 'â”»â”â”» ï¸µãƒ½(`Ğ”Â´)ï¾‰ï¸µ â”»â”â”»',
            '(down)': 'â†“', '(duckface)': '(ãƒ»3ãƒ»)', '(duel)': 'á••(â•­à²°â•­ ÍŸÊ–â•®â€¢Ì)âŠƒÂ¤=(â€”â€”â€”â€”-', '(duh)': '(â‰§ï¸¿â‰¦)',
            '(dunno)': 'Â¯\\(Â°_o)/Â¯', '(ebola)': 'á´‡Ê™á´ÊŸá´€', '(eeriemob)': '(-(-_-(-_(-_(-_-)_-)-_-)_-)_-)-)',
            '(ellipsis)': 'â€¦', '(...)': 'â€¦', '(emdash)': 'â€“', '(--)': 'â€“', '(emptystar)': 'â˜†',
            '(emptytriangle)': 'â–³', '(t2)': 'â–³', '(endure)': '(Ò‚â—¡_â—¡) á•¤', '(envelope)': 'âœ‰ï¸', '(letter)': 'âœ‰ï¸',
            '(epsilon)': 'É›', '(euro)': 'â‚¬', '(evil)': 'Ïˆ(ï½€âˆ‡Â´)Ïˆ', '(evillenny)': '(Í â‰– ÍœÊ–Í â‰–)',
            '(excited)': '(ï¾‰â—•ãƒ®â—•)ï¾‰*:ãƒ»ï¾Ÿâœ§', '(execution)': '(âŒâ– _â– )ï¸»â•¦â•¤â”€ (â•¥ï¹â•¥)', '(facebook)': '(â•¯Â°â–¡Â°)â•¯ï¸µ ÊooqÇÉ”ÉÉŸ',
            '(facepalm)': '(ï¼â€¸áƒš)', '(fancytext)': 'Ğ²Ñ”Ï‰Î±ÑÑ”, Î¹ Î±Ğ¼ Æ’Î±Î·Â¢Ñƒ!', '(fart)': '(Ë†âº«Ë†à¹‘)<3', '(fight)': '(à¸‡ â€¢Ì€_â€¢Ì)à¸‡',
            '(finn)': '| (â€¢ â—¡â€¢)|', '(fish)': '<"(((<3', '(5)': 'åŒ', '(five)': 'åŒ', '(5/8)': 'â…', '(flat)': 'â™­',
            '(bemolle)': 'â™­', '(flexing)': 'á•™(`â–½Â´)á•—', '(fliptext)': 'Ç×ŸqÉÊ‡ É ÇÊÄ±×Ÿ ÇÉ¯ dÄ±×ŸÉŸ',
            '(fliptexttable)': '(ãƒ ã‚œĞ”ã‚œ)ãƒ ï¸µ Ç×ŸqÉÊ‡ É ÇÊÄ±×Ÿ Ê‡xÇÊ‡ dÄ±×ŸÉŸ', '(flipped)': 'â”¬â”€â”¬ï»¿ ï¸µ /(.â–¡. \\ï¼‰',
            '(heavytable)': 'â”¬â”€â”¬ï»¿ ï¸µ /(.â–¡. \\ï¼‰', '(flower)': '(âœ¿â— â€¿â— )', '(flor)': '(âœ¿â— â€¿â— )', '(f)': 'âœ¿',
            '(fly)': 'â”€=â‰¡Î£((( ã¤â—•Ù„Íœâ—•)ã¤', '(friendflip)': '(â•¯Â°â–¡Â°)â•¯ï¸µ â”»â”â”» ï¸µ â•¯(Â°â–¡Â° â•¯)', '(frown)': '(áƒ¦Ë˜âŒ£Ë˜áƒ¦)',
            '(fuckoff)': 'à­§à¼¼à² ç›Šà² â•­âˆ©â•®à¼½', '(gtfo)': 'à­§à¼¼à² ç›Šà² â•­âˆ©â•®à¼½', '(fuckyou)': 'â”ŒĞŸâ”(à² _à² )', '(fu)': 'â”ŒĞŸâ”(à² _à² )',
            '(gentleman)': 'à² _à²°à³ƒ', '(sir)': 'à² _à²°à³ƒ', '(monocle)': 'à² _à²°à³ƒ', '(ghast)': '= _ =', '(ghost)': 'à¼¼ ã¤ â•¹ â•¹ à¼½ã¤',
            '(gift)': '(Â´ãƒ»Ï‰ãƒ»)ã£ç”±', '(present)': '(Â´ãƒ»Ï‰ãƒ»)ã£ç”±', '(gimme)': 'à¼¼ ã¤ â—•_â—• à¼½ã¤',
            '(givemeyourmoney)': '(â€¢-â€¢)âŒ', '(glitter)': '(*ãƒ»â€¿ãƒ»)ãƒâŒ’*:ï½¥ï¾Ÿâœ§', '(glasses)': '(âŒ Í¡â–  ÍœÊ– Í¡â– )',
            '(glassesoff)': '( Í¡Â° ÍœÊ– Í¡Â°)ï¾‰âŒâ– -â– ', '(glitterderp)': '(ï¾‰â˜‰ãƒ®âš†)ï¾‰ âŒ’*:ï½¥ï¾Ÿâœ§', '(gloomy)': '(_ã‚œ_ã‚œ_)',
            '(goatse)': '(Ğ·à¹Îµ)', '(gotit)': '(â˜ï¾Ÿâˆ€ï¾Ÿ)â˜', '(greet)': '( Â´â—” Ï‰â—”`) ãƒã‚·', '(greetings)': '( Â´â—” Ï‰â—”`) ãƒã‚·',
            '(gun)': 'ï¸»â•¦â•¤â”€', '(mg)': 'ï¸»â•¦â•¤â”€', '(hadouken)': 'à¼¼ã¤à² ç›Šà² à¼½ã¤ â”€=â‰¡Î£O))', '(hammerandsickle)': 'â˜­',
            '(hs)': 'â˜­', '(handleft)': 'â˜œ', '(hl)': 'â˜œ', '(handright)': 'â˜', '(hr)': 'â˜', '(haha)': 'Ù©(^â€¿^)Û¶',
            '(happy)': 'Ù©( à¹‘â•¹ ê‡´â•¹)Û¶', '(happygarry)': 'á••( á› )á•—', '(h)': 'â™¥', '(heart)': 'â™¥', '(hello)': '(Ê˜â€¿Ê˜)â•¯',
            '(ohai)': '(Ê˜â€¿Ê˜)â•¯', '(bye)': '(Ê˜â€¿Ê˜)â•¯', '(help)': '\\(Â°Î©Â°)/', '(highfive)': '._.)/\\(._.',
            '(hitting)': '( ï½€çš¿Â´)ï½¡ï¾/', '(hug)': '(ã¥ï½¡â—•â€¿â€¿â—•ï½¡)ã¥', '(hugs)': '(ã¥ï½¡â—•â€¿â€¿â—•ï½¡)ã¥',
            '(iknowright)': 'â”ï½œï½¥à¸´Ï‰ï½¥à¸´#ï½œâ”Œ', '(ikr)': 'â”ï½œï½¥à¸´Ï‰ï½¥à¸´#ï½œâ”Œ', '(illuminati)': 'à­§(â–²á´—â–²)ãƒ', '(infinity)': 'âˆ',
            '(inf)': 'âˆ', '(inlove)': '(ã£Â´Ï‰`c)â™¡', '(int)': 'âˆ«', '(internet)': 'à¬˜(à©­*ËŠáµ•Ë‹)à©­*â€ŠÌ€Ë‹ ÉªÉ´á´›á´‡Ê€É´á´‡á´›',
            '(interrobang)': 'â€½', '(jake)': '(âá´¥âÊ‹)', '(kappa)': '(Â¬,â€¿,Â¬)', '(kawaii)': 'â‰§â—¡â‰¦',
            '(keen)': 'â”¬â”´â”¬â”´â”¤ÆŸÍ†Ù„ÍœÆŸÍ† à¼½ï¾‰', '(kiahh)': '~\\(â‰§â–½â‰¦)/~', '(kiss)': '(ã¥ ï¿£ Â³ï¿£)ã¥',
            '(kyubey)': 'ï¼äººâ—• â€¿â€¿ â—•äººï¼¼', '(lambda)': 'Î»', '(lazy)': '_(:3ã€âˆ )_', '(left)': 'â†', '(<-)': 'â†',
            '(lenny)': '( Í¡Â° ÍœÊ– Í¡Â°)', '(lennybill)': '[Ì²Ì…$Ì²Ì…(Ì²Ì… Í¡Â° ÍœÊ– Í¡Â°Ì²Ì…)Ì²Ì…$Ì²Ì…]', '(lennyfight)': '(à¸‡ Í Â° ÍŸÊ– Í¡Â°)à¸‡',
            '(lennyflip)': '(ãƒ Í¡Â° ÍœÊ– Í¡Â°ãƒ) ï¸µ ( Íœã€‚ Í¡Ê– Íœã€‚)', '(lennygang)': '( Í¡Â°( Í¡Â° ÍœÊ–( Í¡Â° ÍœÊ– Í¡Â°)Ê– Í¡Â°) Í¡Â°)',
            '(lennyshrug)': 'Â¯\\_( Í¡Â° ÍœÊ– Í¡Â°)_/Â¯', '(lennysir)': '( à²  ÍœÊ– à²°à³ƒ)', '(lennystalker)': 'â”¬â”´â”¬â”´â”¤( Í¡Â° ÍœÊ–â”œâ”¬â”´â”¬â”´',
            '(lennystrong)': 'á•¦( Í¡Â° ÍœÊ– Í¡Â°)á•¤', '(lennywizard)': 'â•°( Í¡Â° ÍœÊ– Í¡Â° )ã¤â”€â”€â˜†*:ãƒ»ï¾Ÿ', '(loading)': 'â–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’',
            '(lol)': 'L(Â° O Â°L)', '(look)': '(à²¡_à²¡)â˜', '(loud)': 'á•¦(â©¾ï¹â©½)á•¥', '(noise)': 'á•¦(â©¾ï¹â©½)á•¥',
            '(love)': 'â™¥â€¿â™¥', '(lovebear)': 'Ê•â™¥á´¥â™¥Ê”', '(lumpy)': 'ê’° ê’¡âŒ“ê’¡ê’±', '(luv)': '-`áƒ¦Â´-',
            '(magic)': 'ãƒ½(ï½€Ğ”Â´)âŠƒâ”â˜†ï¾Ÿ. * ï½¥ ï½¡ï¾Ÿ,', '(magicflip)': '(/Â¯â—¡ â€¿ â—¡)/Â¯ ~ â”»â”â”»', '(meep)': '\\(Â°^Â°)/',
            '(meh)': 'à² _à² ', '(metal)': '\\m/,(> . <)_\\m/', '(rock)': '\\m/,(> . <)_\\m/', '(mistyeyes)': 'à²¡_à²¡',
            '(monster)': 'à¼¼ à¼àº¶ à·´ à¼àº¶à¼½', '(natural)': 'â™®', '(needle)': 'â”Œ(â—‰ ÍœÊ–â—‰)ã¤â”£â–‡â–‡â–‡â•â”€â”€',
            '(inject)': 'â”Œ(â—‰ ÍœÊ–â—‰)ã¤â”£â–‡â–‡â–‡â•â”€â”€', '(nerd)': '(âŒâŠ™_âŠ™)', '(nice)': '( Í¡Â° Íœ Â°)', '(no)': 'â†’_â†',
            '(noclue)': 'ï¼äººâ—• __ â—•äººï¼¼', '(nom)': '(ã£Ë†Ú¡Ë†Ï‚)', '(yummy)': '(ã£Ë†Ú¡Ë†Ï‚)', '(delicious)': '(ã£Ë†Ú¡Ë†Ï‚)',
            '(note)': 'â™«', '(sing)': 'â™«', '(nuclear)': 'â˜¢', '(radioactive)': 'â˜¢', '(nukular)': 'â˜¢',
            '(nyan)': '~=[,,_,,]:3', '(nyeh)': '@^@', '(ohshit)': '( Âºï¹ƒÂº )', '(omega)': 'Î©', '(omg)': 'â—•_â—•',
            '(1/8)': 'â…›', '(1/4)': 'Â¼', '(1/2)': 'Â½', '(1/3)': 'â…“', '(opt)': 'âŒ¥', '(option)': 'âŒ¥', '(orly)': '(ëˆˆ_ëˆˆ)',
            '(ohyou)': '(â—à°¥à±ªà°¥)á´–', '(ou)': '(â—à°¥à±ªà°¥)á´–', '(peace)': 'âœŒ(-â€¿-)âœŒ', '(victory)': 'âœŒ(-â€¿-)âœŒ',
            '(pear)': '(__>-', '(pi)': 'Ï€', '(pingpong)': '( â€¢_â€¢)O*Â¯`Â·.Â¸.Â·Â´Â¯`Â°Q(â€¢_â€¢ )', '(plain)': '._.',
            '(pleased)': '(Ë¶â€¾á·„ â»Ì« â€¾á·…Ëµ)', '(point)': '(â˜ï¾Ÿãƒ®ï¾Ÿ)â˜', '(pooh)': 'Ê• â€¢ÌØˆâ€¢Ì€)', '(porcupine)': '(â€¢á´¥â€¢ )Ì`Ì\'Ì`Ì\'Ìâ»',
            '(pound)': 'Â£', '(praise)': '(â˜ Õà¨Š Õ)â˜', '(punch)': 'O=(\'-\'Q)', '(rage)': 't(à² ç›Šà² t)',
            '(mad)': 't(à² ç›Šà² t)', '(rageflip)': '(ãƒà² ç›Šà² )ãƒå½¡â”»â”â”»', '(rainbowcat)': '(=^ï½¥ï½ªï½¥^=))ï¾‰å½¡â˜†',
            '(really)': 'Ã²_Ã´', '(r)': 'Â®', '(right)': 'â†’', '(->)': 'â†’', '(riot)': 'à­§à¼¼à² ç›Šà² à¼½à­¨', '(rolldice)': 'âšƒ',
            '(rolleyes)': '(â—”_â—”)', '(rose)': 'âœ¿Ú¿Ú°Û£â€”', '(run)': '(â•¯Â°â–¡Â°)â•¯', '(sad)': 'Îµ(Â´×¡Ö¼ï¸µ×¡Ö¼`)Ğ·',
            '(saddonger)': 'ãƒ½à¼¼àºˆÊ–Ì¯àºˆà¼½ï¾‰', '(sadlenny)': '( Í¡Â° Ê–Ì¯ Í¡Â°)', '(7/8)': 'â…', '(sharp)': 'â™¯', '(diesis)': 'â™¯',
            '(shout)': 'â•š(â€¢âŒ‚â€¢)â•', '(shrug)': 'Â¯\\_(ãƒ„)_/Â¯', '(shy)': '=^_^=', '(sigma)': 'Î£', '(sum)': 'Î£',
            '(skull)': 'â˜ ', '(smile)': 'ãƒ„', '(smiley)': 'â˜ºï¸', '(smirk)': 'Â¬â€¿Â¬', '(snowman)': 'â˜ƒ',
            '(sob)': '(;Â´à¼àº¶Ğ”à¼àº¶`)', '(soviettableflip)': 'ãƒâ”¬â”€â”¬ãƒ ï¸µ ( \\oÂ°o)\\', '(spade)': 'â™ ', '(sqrt)': 'âˆš',
            '(squid)': '<ã‚³:å½¡', '(star)': 'â˜…', '(strong)': 'á•™(â‡€â€¸â†¼â€¶)á•—', '(suicide)': 'Îµ/ÌµÍ‡Ì¿Ì¿/â€™Ì¿â€™Ì¿ Ì¿(â—¡ï¸µâ—¡)',
            '(sum)': 'âˆ‘', '(sun)': 'â˜€', '(surprised)': '(à¹‘â€¢Ì ãƒ® â€¢Ì€à¹‘)', '(surrender)': '\\_(-_-)_/',
            '(stalker)': 'â”¬â”´â”¬â”´â”¤(ï½¥_â”œâ”¬â”´â”¬â”´', '(swag)': '(Ì¿â–€Ì¿â€¿â€‰Ì¿â–€Ì¿ Ì¿)', '(sword)': 'o()xxxx[{::::::::::::::::::>',
            '(tabledown)': 'â”¬â”€â”¬ï»¿ ãƒ( ã‚œ-ã‚œãƒ)', '(tableflip)': '(ãƒ ã‚œĞ”ã‚œ)ãƒ ï¸µ â”»â”â”»', '(tau)': 'Ï„', '(tears)': '(à²¥ï¹à²¥)',
            '(terrorist)': 'à­§à¼¼à² ç›Šà² à¼½ï¸»â•¦â•¤â”€', '(thanks)': '\\(^-^)/', '(thankyou)': '\\(^-^)/', '(ty)': '\\(^-^)/',
            '(therefore)': 'â¸«', '(so)': 'â¸«', '(this)': '( Í¡Â° ÍœÊ– Í¡Â°)_/Â¯', '(3/8)': 'â…œ', '(tiefighter)': '|=-(Â¤)-=|',
            '(tired)': '(=____=)', '(toldyouso)': 'â˜œ(ê’¡âŒ“ê’¡)', '(toldyou)': 'â˜œ(ê’¡âŒ“ê’¡)', '(toogood)': 'á•¦(Ã²á´¥Ã³)á•¥',
            '(tm)': 'â„¢', '(triangle)': 'â–²', '(t)': 'â–²', '(2/3)': 'â…”', '(unflip)': 'â”¬â”€â”€â”¬ ãƒ(Ã²_Ã³ãƒ)', '(up)': 'â†‘',
            '(victory)': '(à¹‘â€¢Ì€ã…‚â€¢Ì)à¸‡âœ§', '(wat)': '(Ã’Ğ”Ã“×±)', '(wave)': '( * ^ *) ãƒã‚·', '(whaa)': 'Ã–',
            '(whistle)': '(ã£^Ğ·^)â™ªâ™¬', '(whoa)': '(Â°oâ€¢)', '(why)': 'áƒš(`â—‰â—à±ªâ—Ÿâ—‰â€µáƒš)',
            '(witchtext)': 'WHÎ£Ğ˜ $HÎ›LL WÎ£ â€ HĞ¯Î£Î£ MÎ£Î£â€  Î›GÎ›|Ğ˜?', '(woo)': 'ï¼¼(ï¼¾Oï¼¾)ï¼', '(wtf)': '(âŠ™ï¼¿âŠ™\')',
            '(wut)': 'âŠ™Ï‰âŠ™', '(yay)': '\\( ï¾Ÿãƒ®ï¾Ÿ)/', '(yeah)': '(â€¢Ì€á´—â€¢Ì)Ùˆ Ì‘Ì‘', '(yes)': '(â€¢Ì€á´—â€¢Ì)Ùˆ Ì‘Ì‘', '(yen)': 'Â¥',
            '(yinyang)': 'â˜¯', '(yy)': 'â˜¯', '(yolo)': 'Yáµ’áµ˜ Oá¶°Ë¡Ê¸ Lá¶¤áµ›áµ‰ Oá¶°á¶œáµ‰', '(youkids)': 'áƒšà¼¼>â•­ ÍŸÊ–â•®<à¼½áƒš',
            '(ukids)': 'áƒšà¼¼>â•­ ÍŸÊ–â•®<à¼½áƒš', '(y u no)': '(å±®ï¾ŸĞ”ï¾Ÿ)å±® Y U NO', '(yuno)': '(å±®ï¾ŸĞ”ï¾Ÿ)å±® Y U NO',
            '(zen)': 'âŠ¹â•°(âŒ£ÊŸâŒ£)â•¯âŠ¹', '(meditation)': 'âŠ¹â•°(âŒ£ÊŸâŒ£)â•¯âŠ¹', '(omm)': 'âŠ¹â•°(âŒ£ÊŸâŒ£)â•¯âŠ¹',
            '(zoidberg)': '(V) (Â°,,,,Â°) (V)', '(zombie)': '[Â¬Âº-Â°]Â¬'
        };

        // --- Sound System ---
        const SoundSys = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone: function(freq, type, duration, vol=0.1) {
                if (state.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            click: function() { this.playTone(800, 'square', 0.05, 0.05); },
            blip: function() { this.playTone(1200, 'sine', 0.15, 0.1); }
        };

        // --- Theme System ---
        const Themes = {
            green: { main: '#33ff00', system: '#ffaa00', chat: '#00ccff', error: '#ff3333' },
            amber: { main: '#ffb000', system: '#ffcc00', chat: '#ffb000', error: '#ff5500' },
            blue:  { main: '#0088ff', system: '#00aaff', chat: '#00ffff', error: '#ff3333' },
            white: { main: '#e0e0e0', system: '#ffffff', chat: '#cccccc', error: '#ff3333' },
            matrix: { main: '#00ff41', system: '#008f11', chat: '#003b00', error: '#ff3333' }
        };

        function applyTheme(themeName) {
            const theme = Themes[themeName];
            if (!theme) return false;
            const r = document.documentElement;
            r.style.setProperty('--terminal-main', theme.main);
            r.style.setProperty('--terminal-glow', theme.main);
            r.style.setProperty('--system-color', theme.system);
            r.style.setProperty('--chat-color', theme.chat);
            r.style.setProperty('--error-color', theme.error);
            return true;
        }

        // --- UI References ---
        const input = document.getElementById('command-input');
        const history = document.getElementById('chat-history');
        const container = document.getElementById('terminal-container');
        const promptSpan = document.getElementById('prompt-span');
        const cmdBefore = document.getElementById('cmd-before');
        const cmdCursor = document.getElementById('cmd-cursor');
        const cmdAfter = document.getElementById('cmd-after');
        const autocompleteMenu = document.getElementById('autocomplete-menu');

        function updateInputDisplay() {
            const val = input.value;
            const selStart = input.selectionStart || 0;
            const left = val.substring(0, selStart);
            const char = val.substring(selStart, selStart + 1) || '\u00A0';
            const right = val.substring(selStart + 1);

            cmdBefore.textContent = left;
            cmdCursor.textContent = char;
            cmdAfter.textContent = right;
        }

        ['input', 'click', 'focus', 'blur'].forEach(evt => {
            input.addEventListener(evt, () => requestAnimationFrame(updateInputDisplay));
        });

        // --- Autocomplete Logic ---
        function showAutocompleteMenu(options) {
            autocompleteMenu.innerHTML = '';
            autocompleteOptions = options;
            autocompleteIndex = -1;

            if (options.length === 0) {
                autocompleteMenu.style.display = 'none';
                return;
            }

            options.forEach((opt, index) => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.textContent = opt;
                div.onclick = () => confirmSelection(opt);
                autocompleteMenu.appendChild(div);
            });

            autocompleteMenu.style.display = 'flex';
        }

        function hideAutocomplete() {
            autocompleteMenu.style.display = 'none';
            autocompleteOptions = [];
            autocompleteIndex = -1;
        }

        function highlightOption(index) {
            const items = autocompleteMenu.children;
            for (let i = 0; i < items.length; i++) {
                items[i].classList.remove('selected');
            }
            if (index >= 0 && index < items.length) {
                items[index].classList.add('selected');
                items[index].scrollIntoView({ block: 'nearest' });
            }
        }

        function confirmSelection(selectedValue) {
            const val = input.value;
            // Find the last word being typed (split by space)
            // Note: In this simple terminal, we assume cursor is at end for this logic
            // or at least we are completing the last token.
            const lastSpaceIdx = val.lastIndexOf(' ');
            
            if (lastSpaceIdx === -1) {
                // Replacing the first/only word
                input.value = selectedValue + ' ';
            } else {
                // Replacing the last word, preserving prefix
                const prefix = val.substring(0, lastSpaceIdx + 1);
                input.value = prefix + selectedValue + ' ';
            }
            
            hideAutocomplete();
            updateInputDisplay();
            input.focus();
        }

        function handleTabCompletion(e) {
            e.preventDefault();

            // If menu is open, cycle through it
            if (autocompleteMenu.style.display === 'flex') {
                autocompleteIndex = (autocompleteIndex + 1) % autocompleteOptions.length;
                highlightOption(autocompleteIndex);
                return;
            }

            // Logic to find matches
            const val = input.value;
            const parts = val.split(' '); // Simple tokenize by space
            const currentWord = parts[parts.length - 1]; // Word currently being typed
            
            let matches = [];

            // 1. Emoji Autocomplete (Priority if starts with '(')
            if (currentWord.startsWith('(')) {
                const emojiKeys = Object.keys(EMOJI_MAP);
                matches = emojiKeys.filter(key => key.startsWith(currentWord));
            }
            // 2. Command Autocomplete (1st word only)
            else if (parts.length === 1 && currentWord !== "") {
                 matches = commandsList.filter(cmd => cmd.startsWith(currentWord));
            }
            // 3. Subcommand Autocomplete (2nd word only)
            else if (parts.length === 2 && !currentWord.startsWith('(')) {
                const cmd = parts[0];
                if (subCommands[cmd]) {
                    matches = subCommands[cmd].filter(sub => sub.startsWith(currentWord));
                }
            }

            if (matches.length === 1) {
                // Exact match, just fill it
                confirmSelection(matches[0]);
            } else if (matches.length > 1) {
                // Multiple matches, show menu
                showAutocompleteMenu(matches);
            }
        }

        // --- Auth & Presence ---
        const initGuestAuth = async () => {
            try { await signInAnonymously(auth); } 
            catch (e) { console.warn("Guest login failed:", e.code); }
        };

        const updateStatus = async (status) => {
            if (!currentUser || currentUser.isAnonymous) return;
            try {
                const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', currentUser.uid);
                await setDoc(userRef, {
                    status: status,
                    lastSeen: serverTimestamp()
                }, { merge: true });
                return true;
            } catch(e) { console.error(e); return false; }
        };

        onAuthStateChanged(auth, async (user) => {
            currentUser = user;
            if (user) {
                if (user.isAnonymous) {
                     updatePrompt('guest');
                     addMessage('SYSTEM', 'GUEST MODE ACTIVE.', true);
                } else {
                    updatePrompt(user.email.split('@')[0]);
                    addMessage('SYSTEM', `AUTHENTICATED AS ${user.email}`, true);
                    // Initial Status Set
                    await updateStatus('online');
                    
                    // Profile Init
                    try {
                        const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', user.uid);
                        await setDoc(userRef, {
                            email: user.email,
                            displayName: user.displayName || user.email.split('@')[0],
                            uid: user.uid,
                            status: 'online',
                            lastSeen: serverTimestamp()
                        }, { merge: true });
                    } catch (e) {}
                }
            } else {
                updatePrompt('offline');
                initGuestAuth();
            }
        });

        const handleLogin = async () => {
            try {
                addMessage('SYSTEM', 'INITIATING GOOGLE AUTH HANDSHAKE...', true);
                const provider = new GoogleAuthProvider();
                await signInWithPopup(auth, provider);
            } catch (error) {
                if (error.code === 'auth/unauthorized-domain') {
                    addMessage('ERROR', 'DOMAIN NOT AUTHORIZED. Check Firebase Console.', false, false, true);
                } else {
                    addMessage('ERROR', `LOGIN FAILED: ${error.message}`, false, false, true);
                }
            }
        };

        function updatePrompt(username) {
            if (state.mode === 'CHAT') {
                promptSpan.textContent = `[CHAT:${currentChatPartner.nickname || currentChatPartner.email}] >`;
            } else {
                promptSpan.textContent = `${username}@TChat:~$`;
            }
        }

        // --- Effects ---
        function parseEmojis(text) {
             return text.replace(/\([^)]+\)/g, (match) => EMOJI_MAP[match] || match);
        }

        function scrambleText(element, finalValidText) {
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()";
            let iterations = 0;
            const originalText = finalValidText;
            
            const interval = setInterval(() => {
                element.innerText = originalText.split('').map((char, index) => {
                    if (char === ' ' || char === '\n') return char; 
                    if (index < iterations) return originalText[index];
                    return chars[Math.floor(Math.random() * chars.length)];
                }).join('');
                
                if (iterations >= originalText.length) {
                    clearInterval(interval);
                    element.innerText = originalText;
                }
                iterations += 1 + Math.floor(originalText.length / 30); 
            }, 50);
        }

        // Map Firestore msg ID to DOM element for deletion
        const msgMap = new Map();

        function addMessage(sender, text, isSystem = false, isChat = false, isError = false, isAscii = false, msgId = null, isBurn = false) {
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('message-line');
            if (isSystem) msgDiv.classList.add('system-msg');
            if (isChat) msgDiv.classList.add('chat-msg');
            if (isError) msgDiv.classList.add('error-msg');
            if (isAscii) msgDiv.classList.add('ascii-art');

            if (msgId) {
                msgDiv.setAttribute('data-msg-id', msgId);
                msgMap.set(msgId, msgDiv);
            }

            if (!state.muted && (isSystem || (isChat && sender !== 'ME'))) {
                setTimeout(() => SoundSys.blip(), 50);
            }

            const contentSpan = document.createElement('span');

            if (sender) {
                let prefixColor = 'var(--terminal-main)';
                if (isChat) prefixColor = 'var(--chat-color)';
                if (isSystem) prefixColor = 'var(--system-color)';
                if (isError) prefixColor = 'var(--error-color)';
                
                const prefixSpan = document.createElement('span');
                prefixSpan.className = 'user-prefix';
                prefixSpan.style.color = prefixColor;
                prefixSpan.textContent = `[${sender}]: `;
                msgDiv.appendChild(prefixSpan);
            }

            if (isAscii) {
                contentSpan.textContent = text;
            } else {
                contentSpan.textContent = text; 
            }

            msgDiv.appendChild(contentSpan);

            // Burn Logic Visuals
            if (isBurn) {
                const burnSpan = document.createElement('span');
                burnSpan.className = 'burn-timer';
                burnSpan.textContent = ' [ğŸ”¥ 10s]';
                msgDiv.appendChild(burnSpan);

                // Local countdown visual (actual deletion handled by DB listener or sender)
                let left = 10;
                const timer = setInterval(() => {
                    left--;
                    if(left >= 0) burnSpan.textContent = ` [ğŸ”¥ ${left}s]`;
                    else {
                        clearInterval(timer);
                    }
                }, 1000);
            }

            history.appendChild(msgDiv);
            scrollToBottom();

            if ((isChat && sender !== 'ME') || isSystem) {
                if (!isAscii) scrambleText(contentSpan, text);
            }

            return msgDiv;
        }

        function scrollToBottom() {
            container.scrollTop = container.scrollHeight;
        }

        // --- Command Processing ---
        input.addEventListener('keydown', function(event) {
            SoundSys.init();
            
            // --- Autocomplete Handling ---
            if (event.key === 'Tab') {
                handleTabCompletion(event);
                return; // Stop other processing
            }

            // If menu is open, handle navigation keys specially
            if (autocompleteMenu.style.display === 'flex') {
                if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    autocompleteIndex = (autocompleteIndex - 1 + autocompleteOptions.length) % autocompleteOptions.length;
                    highlightOption(autocompleteIndex);
                    return;
                }
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    autocompleteIndex = (autocompleteIndex + 1) % autocompleteOptions.length;
                    highlightOption(autocompleteIndex);
                    return;
                }
                if (event.key === 'Enter') {
                    if (autocompleteIndex >= 0) {
                        event.preventDefault();
                        confirmSelection(autocompleteOptions[autocompleteIndex]);
                        return;
                    }
                    // If no selection, allow Enter to submit command normally, but hide menu
                    hideAutocomplete();
                }
                if (event.key === 'Escape') {
                    hideAutocomplete();
                    return;
                }
            } else {
                // --- Normal History Navigation (only if menu closed) ---
                if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    if (cmdHistory.length > 0) {
                        if (historyIndex < cmdHistory.length - 1) {
                            historyIndex++;
                            input.value = cmdHistory[cmdHistory.length - 1 - historyIndex];
                            updateInputDisplay();
                        }
                    }
                    return;
                }
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        input.value = cmdHistory[cmdHistory.length - 1 - historyIndex];
                    } else if (historyIndex === 0) {
                        historyIndex = -1;
                        input.value = '';
                    }
                    updateInputDisplay();
                    return;
                }
            }

            // --- Hiding menu on typing (reset) ---
            if (event.key.length === 1 || event.key === 'Backspace') {
                 if (event.key !== 'Tab') hideAutocomplete();
            }

            if (!['Enter', 'Shift', 'Control', 'Alt', 'ArrowUp', 'ArrowDown', 'Tab'].includes(event.key)) {
                SoundSys.click();
            }

            if (event.key === 'Enter') {
                const text = input.value; 
                const trimmed = text.trim();
                
                if (trimmed !== "") {
                    cmdHistory.push(trimmed);
                    historyIndex = -1;

                    if (state.mode === 'COMMAND') {
                        addMessage('ME', trimmed);
                        processCommand(trimmed);
                    } else {
                        processChatInput(trimmed);
                    }
                    input.value = '';
                    updateInputDisplay();
                }
            }
            requestAnimationFrame(updateInputDisplay);
        });

        document.addEventListener('click', (e) => { 
            input.focus(); 
            SoundSys.init();
            if (e.target !== autocompleteMenu && e.target.parentElement !== autocompleteMenu) {
                hideAutocomplete();
            }
        });
        window.onload = () => input.focus();

        async function processCommand(rawCmd) {
            const parts = rawCmd.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);

            switch (cmd) {
                case 'help':
                    addMessage('SYSTEM', 'COMMANDS:', true);
                    addMessage(null, '  login            - Sign in with Google');
                    addMessage(null, '  friend add [email]     - Add friend');
                    addMessage(null, '  friend nick [email] [nick] - Set nickname');
                    addMessage(null, '  friends          - List friends');
                    addMessage(null, '  friends-email    - List emails & nicknames');
                    addMessage(null, '  status [mode]    - online/away/busy');
                    addMessage(null, '  chat [name/email] - Start chat');
                    addMessage(null, '  burn [msg]       - Send self-destruct msg');
                    addMessage(null, '  theme [color]    - Set color');
                    addMessage(null, '  ascii [url]      - Render ASCII');
                    addMessage(null, '  emoji            - List emoji codes');
                    addMessage(null, '  mute / unmute    - Toggle sounds');
                    addMessage(null, '  clear            - Clear screen');
                    break;

                case 'clear':
                    history.innerHTML = '';
                    break;

                case 'emoji':
                    addMessage('SYSTEM', 'AVAILABLE EMOJIS (Type code to use):', true);
                    const emojiList = Object.keys(EMOJI_MAP).join(' ');
                    addMessage(null, emojiList);
                    break;

                case 'status':
                    if (!ensureAuth()) return;
                    const validStatuses = ['online', 'away', 'busy'];
                    if (args[0] && validStatuses.includes(args[0])) {
                        await updateStatus(args[0]);
                        addMessage('SYSTEM', `STATUS SET TO: ${args[0].toUpperCase()}`, true);
                    } else {
                        addMessage('SYSTEM', 'USAGE: status [online | away | busy]', true);
                    }
                    break;

                case 'burn':
                    if (state.mode === 'CHAT') {
                        addMessage('ERROR', 'ENTER A CHAT ROOM TO USE BURN.', false, false, true);
                    } else {
                        addMessage('ERROR', 'ENTER A CHAT ROOM TO USE BURN.', false, false, true);
                    }
                    break;

                case 'mute':
                    state.muted = true;
                    addMessage('SYSTEM', 'SOUNDS MUTED.', true);
                    break;

                case 'unmute':
                    state.muted = false;
                    SoundSys.init();
                    SoundSys.blip(); 
                    addMessage('SYSTEM', 'SOUNDS ACTIVE.', true);
                    break;
                
                case 'ascii':
                    if (args[0]) {
                        addMessage('SYSTEM', `FETCHING ASCII FROM ${args[0]}...`, true);
                        try {
                            const response = await fetch(args[0]);
                            if (!response.ok) throw new Error("Network error");
                            const text = await response.text();
                            addMessage(null, text, false, false, false, true);
                        } catch (e) {
                            addMessage('ERROR', `FAILED: ${e.message}`, false, false, true);
                        }
                    } else {
                        addMessage('SYSTEM', 'USAGE: ascii [url]', true);
                    }
                    break;

                case 'theme':
                    if (args[0] && applyTheme(args[0])) {
                        addMessage('SYSTEM', `THEME SET TO ${args[0].toUpperCase()}`, true);
                    } else {
                        addMessage('SYSTEM', 'USAGE: theme [green|amber|blue|white|matrix]', true);
                    }
                    break;

                case 'login':
                    if (currentUser && !currentUser.isAnonymous) {
                        addMessage('SYSTEM', 'ALREADY LOGGED IN.', true);
                    } else {
                        await handleLogin();
                    }
                    break;

                case 'friend':
                    if (!ensureAuth()) return;
                    if (args[0] === 'add' && args[1]) {
                        addFriend(args[1]);
                    } else if (args[0] === 'nick' && args[1] && args[2]) {
                        setNickname(args[1], args[2]);
                    } else {
                        addMessage('SYSTEM', 'USAGE: friend add [email] OR friend nick [email] [nick]', true);
                    }
                    break;

                case 'friends':
                    if (!ensureAuth()) return;
                    listFriends();
                    break;

                case 'friends-email':
                    if (!ensureAuth()) return;
                    listFriendsEmails();
                    break;

                case 'chat':
                    if (!ensureAuth()) return;
                    if (args[0]) {
                        startChat(args[0]);
                    } else {
                        addMessage('SYSTEM', 'USAGE: chat [name/email]', true);
                    }
                    break;

                case 'date':
                    addMessage('SYSTEM', new Date().toString(), true);
                    break;

                case 'exit':
                    break;

                default:
                    addMessage('SYSTEM', `UNKNOWN COMMAND: ${cmd}`, true);
            }
        }

        function ensureAuth() {
            if (!currentUser || currentUser.isAnonymous) {
                addMessage('ERROR', 'ACCESS DENIED. LOGIN REQUIRED.', false, false, true);
                return false;
            }
            return true;
        }

        // --- Feature Implementation ---

        async function addFriend(targetEmail) {
            addMessage('SYSTEM', `SEARCHING...`, true);
            try {
                const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'user_profiles');
                const q = query(usersRef, where("email", "==", targetEmail));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    addMessage('ERROR', 'USER NOT FOUND.', false, false, true);
                    return;
                }
                const targetUser = snapshot.docs[0].data();
                const myFriendsRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'friends', targetUser.uid);
                await setDoc(myFriendsRef, {
                    email: targetUser.email,
                    uid: targetUser.uid,
                    displayName: targetUser.displayName,
                    addedAt: serverTimestamp()
                }, { merge: true });
                addMessage('SYSTEM', `FRIEND ADDED.`, true);
            } catch (error) {
                addMessage('ERROR', 'DB ERROR: ' + error.message, false, false, true);
            }
        }

        async function setNickname(targetEmail, nickname) {
            addMessage('SYSTEM', `SETTING NICKNAME...`, true);
            try {
                // Find friend by email in my friends list
                const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                const q = query(friendsRef, where("email", "==", targetEmail));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    addMessage('ERROR', 'FRIEND NOT FOUND IN LIST. ADD FIRST.', false, false, true);
                    return;
                }

                const friendDoc = snapshot.docs[0];
                await setDoc(friendDoc.ref, { nickname: nickname }, { merge: true });
                addMessage('SYSTEM', `NICKNAME SET: ${nickname} -> ${targetEmail}`, true);
            } catch (error) {
                addMessage('ERROR', 'UPDATE FAILED: ' + error.message, false, false, true);
            }
        }

        async function listFriends() {
            addMessage('SYSTEM', 'FETCHING FRIEND LIST...', true);
            try {
                const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                const snapshot = await getDocs(friendsRef);
                if (snapshot.empty) {
                    addMessage(null, 'No friends found.');
                    return;
                }
                
                // Fetch status for each friend
                const promises = snapshot.docs.map(async (docSnap) => {
                    const friend = docSnap.data();
                    const profileRef = doc(db, 'artifacts', appId, 'public', 'data', 'user_profiles', friend.uid);
                    const profileSnap = await getDoc(profileRef);
                    let status = 'offline';
                    if (profileSnap.exists()) {
                        status = profileSnap.data().status || 'offline';
                    }
                    return { ...friend, status };
                });

                const friendsWithStatus = await Promise.all(promises);

                friendsWithStatus.forEach(f => {
                    let dotClass = 'status-online'; 
                    if (f.status === 'away') dotClass = 'status-away';
                    if (f.status === 'busy') dotClass = 'status-busy';
                    
                    const displayName = f.nickname ? `${f.nickname} <${f.email}>` : f.email;
                    
                    const div = document.createElement('div');
                    div.className = 'message-line';
                    div.innerHTML = `<span class="status-dot ${dotClass}">â—</span> ${displayName}`;
                    history.appendChild(div);
                });
                scrollToBottom();

            } catch (error) {
                addMessage('ERROR', error.message, false, false, true);
            }
        }

        async function listFriendsEmails() {
            addMessage('SYSTEM', 'FETCHING CONTACTS...', true);
            try {
                const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                const snapshot = await getDocs(friendsRef);
                if (snapshot.empty) {
                    addMessage(null, 'No friends found.');
                    return;
                }
                
                snapshot.forEach(docSnap => {
                    const f = docSnap.data();
                    const info = f.nickname ? `NICK: ${f.nickname} | EMAIL: ${f.email}` : `EMAIL: ${f.email}`;
                    addMessage(null, info);
                });
                scrollToBottom();

            } catch (error) {
                addMessage('ERROR', error.message, false, false, true);
            }
        }

        async function startChat(identifier) {
            try {
                const friendsRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                
                // Strategy 1: Try finding by nickname first
                let q = query(friendsRef, where("nickname", "==", identifier));
                let snapshot = await getDocs(q);

                // Strategy 2: If not found, try finding by email
                if (snapshot.empty) {
                    q = query(friendsRef, where("email", "==", identifier));
                    snapshot = await getDocs(q);
                }

                if (snapshot.empty) {
                    addMessage('ERROR', 'FRIEND NOT FOUND (CHECK NICK OR EMAIL).', false, false, true);
                    return;
                }

                const friendData = snapshot.docs[0].data();
                currentChatPartner = friendData;
                
                state.mode = 'CHAT';
                history.innerHTML = ''; 
                // Prefer nickname in display
                const chatName = friendData.nickname || friendData.email;
                addMessage('SYSTEM', `--- CONNECTION ESTABLISHED: ${chatName} ---`, true);
                addMessage('SYSTEM', `CMDS: 'burn [msg]', 'ascii [url]', 'exit'`, true);
                updatePrompt(currentUser.email);

                const convoId = getConversationId(currentUser.uid, friendData.uid);
                const msgsRef = collection(db, 'artifacts', appId, 'public', 'data', 'messages');
                
                const qMsg = query(msgsRef, where('conversationId', '==', convoId), orderBy('timestamp', 'asc'));

                if (messagesUnsubscribe) messagesUnsubscribe();

                messagesUnsubscribe = onSnapshot(qMsg, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        // HANDLE ADDED
                        if (change.type === "added") {
                            const msg = change.doc.data();
                            let senderName;
                            if (msg.senderId === currentUser.uid) {
                                senderName = 'ME';
                            } else {
                                // Use nickname if available
                                senderName = friendData.nickname || friendData.email.split('@')[0];
                            }
                            addMessage(senderName, msg.text, false, true, false, msg.isAscii || false, change.doc.id, msg.burn);
                        }
                        // HANDLE REMOVED (Burned messages)
                        if (change.type === "removed") {
                            const msgId = change.doc.id;
                            const el = msgMap.get(msgId);
                            if (el) {
                                el.style.opacity = '0';
                                setTimeout(() => el.remove(), 500); 
                                msgMap.delete(msgId);
                            }
                        }
                    });
                }, (error) => {
                     if(error.message.includes("index")) {
                         addMessage('ERROR', 'INDEX REQUIRED. Check console.', false, false, true);
                         console.error(error);
                     }
                });
            } catch (error) {
                addMessage('ERROR', 'CHAT ERROR: ' + error.message, false, false, true);
            }
        }

        async function processChatInput(text) {
            const lowText = text.toLowerCase();
            
            if (lowText === 'exit') {
                if (messagesUnsubscribe) messagesUnsubscribe();
                messagesUnsubscribe = null;
                state.mode = 'COMMAND';
                currentChatPartner = null;
                history.innerHTML = '';
                addMessage('SYSTEM', 'DISCONNECTED.', true);
                updatePrompt(currentUser.email.split('@')[0]);
                return;
            }

            let isBurn = false;
            let isAscii = false;
            let finalBody = text;
            
            if (lowText.startsWith('burn ')) {
                isBurn = true;
                finalBody = text.substring(5); // Remove 'burn '
            }

            // Check for ASCII command inside chat
            if (finalBody.toLowerCase().startsWith('ascii ')) {
                addMessage('SYSTEM', 'FETCHING ASCII ART...', true);
                const url = finalBody.substring(6).trim();
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error("Network error");
                    finalBody = await response.text();
                    isAscii = true;
                } catch (e) {
                    addMessage('ERROR', 'FAILED TO FETCH ASCII: ' + e.message, false, false, true);
                    return;
                }
            }

            // Parse Emojis
            finalBody = parseEmojis(finalBody);

            const convoId = getConversationId(currentUser.uid, currentChatPartner.uid);
            const msgsRef = collection(db, 'artifacts', appId, 'public', 'data', 'messages');

            try {
                const docRef = await addDoc(msgsRef, {
                    conversationId: convoId,
                    text: finalBody,
                    senderId: currentUser.uid,
                    receiverId: currentChatPartner.uid,
                    burn: isBurn,
                    isAscii: isAscii,
                    timestamp: serverTimestamp()
                });

                // If it's a burn message, schedule deletion from the sender side
                if (isBurn) {
                    setTimeout(async () => {
                        try {
                            await deleteDoc(docRef);
                            // Visual removal happens via onSnapshot 'removed' event
                        } catch(e) { console.error("Burn failed", e); }
                    }, 10000);
                }

            } catch (e) {
                addMessage('ERROR', 'SEND FAILED: ' + e.message, false, false, true);
            }
        }

        function getConversationId(uid1, uid2) {
            return [uid1, uid2].sort().join('_');
        }

    </script>
</body>
</html>